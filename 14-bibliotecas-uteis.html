<!DOCTYPE HTML>
<html lang="pt" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Bibliotecas uteis - C Para Seres Humanos</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="0-sobre.html"><strong aria-hidden="true">1.</strong> Sobre</a></li><li class="chapter-item expanded "><a href="1-nocoes-basicas.html"><strong aria-hidden="true">2.</strong> Nocoes basicas</a></li><li class="chapter-item expanded "><a href="2-introducao-a-sintaxe-do-c.html"><strong aria-hidden="true">3.</strong> Introducao a sintaxe do C</a></li><li class="chapter-item expanded "><a href="3-conceitos-interessantes.html"><strong aria-hidden="true">4.</strong> Conceitos interessantes</a></li><li class="chapter-item expanded "><a href="4-entrada-e-saida-de-dados.html"><strong aria-hidden="true">5.</strong> Entrada e saida de dados</a></li><li class="chapter-item expanded "><a href="5-operadores.html"><strong aria-hidden="true">6.</strong> Operadores</a></li><li class="chapter-item expanded "><a href="6-arrays-e-strings.html"><strong aria-hidden="true">7.</strong> Arrays e Strings</a></li><li class="chapter-item expanded "><a href="7-escopo-e-condicionais.html"><strong aria-hidden="true">8.</strong> Escopo e Condicionais</a></li><li class="chapter-item expanded "><a href="8-estruturas-de-repeticao.html"><strong aria-hidden="true">9.</strong> Estruturas de repeticao</a></li><li class="chapter-item expanded "><a href="9-funcoes.html"><strong aria-hidden="true">10.</strong> Funcoes</a></li><li class="chapter-item expanded "><a href="9-ponteiros.html"><strong aria-hidden="true">11.</strong> Ponteiros</a></li><li class="chapter-item expanded "><a href="10-customizacao-de-tipos.html"><strong aria-hidden="true">12.</strong> Customizacao de tipos</a></li><li class="chapter-item expanded "><a href="11-hacks-e-extras.html"><strong aria-hidden="true">13.</strong> Hacks e Extras</a></li><li class="chapter-item expanded "><a href="13-hello-world-grafico.html"><strong aria-hidden="true">14.</strong> Hello World Grafico</a></li><li class="chapter-item expanded "><a href="14-bibliotecas-uteis.html" class="active"><strong aria-hidden="true">15.</strong> Bibliotecas uteis</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">C Para Seres Humanos</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/plankiton/CParaSeresHumanos" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/mdBook/edit/master/guide/src/14-bibliotecas-uteis.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="bibliotecas-Úteis"><a class="header" href="#bibliotecas-Úteis">Bibliotecas Úteis</a></h1>
<p>Até agora só usamos duas bibliotecas em nossos porgramas em C, e não vimos nem 10% dessas, então para deixar seu conhecimento mais completo aqui vamos mostrar algumas funções dessas duas bibliotecas, além de outras que também podem ser bem interessantes.</p>
<h2 id="stdioh"><a class="header" href="#stdioh">stdio.h</a></h2>
<pre><code class="language-c">#include &lt;stdio.h&gt;
</code></pre>
<p>Como já vimos as funções <code>scanf</code>, <code>printf</code>, <code>putchar</code>, <code>puts</code>, <code>getchar</code>, <code>gets</code>, <code>fprintf</code> e <code>fgets</code>, iremos ignorá-las.</p>
<p>O <code>std</code> significa exclusivamente “standard” (”padrão” em português), <code>i</code> é de “input” (entrada) e o <code>o</code> de “output” (saída), portanto entrada e saída de dados padrão.</p>
<h3 id="io-em-arquivos"><a class="header" href="#io-em-arquivos">I/O em arquivos</a></h3>
<p>Como o <code>stdio</code> serve para entrada e saída de dados, óbviamente também é usada para manipulação de arquivos, usada tanto para ler (input), quanto para escrever (output) neles.</p>
<p>Para ler um arquivo precisamos criar um ponteiro do tipo <code>FILE</code></p>
<pre><code class="language-c">FILE * arquivo;
</code></pre>
<h4 id="leitura"><a class="header" href="#leitura">Leitura</a></h4>
<blockquote>
<p>crie um arquivo <code>j.txt</code> com “joao” escrito dentro</p>
</blockquote>
<p>Para abrir o arquivo <code>j.txt</code> no nosso programa, é só usar a função <code>fopen</code>.</p>
<pre><code class="language-c">arquivo = fopen(&quot;j.txt&quot;, &quot;r&quot;);
</code></pre>
<blockquote>
<p>O <code>&quot;r&quot;</code> no segundo parametro é o modo desse arquivo, nesse caso, abrimos um arquivo em modo leitura.</p>
</blockquote>
<p>Para ler e exibir o que foi lido é só usar o <code>fgetc</code>:</p>
<pre><code class="language-c">char caractere = fgetc(arquivo);
</code></pre>
<blockquote>
<p>O <code>fgetc</code> retorna um caractere de cada vez, e quando le o caractere, quando você for ler de novo ele lerá somente o próximo, exemplo:</p>
</blockquote>
<pre><code class="language-c">// suponha que o arquivo &quot;texto.txt&quot; tem &quot;abc&quot; escrito dentro
FILE *f = fopen(&quot;texto.txt&quot;, &quot;r&quot;);
char a, b, c;

b = fgetc(f); // -&gt; &quot;a&quot;
c = fgetc(f); // -&gt; &quot;b&quot;
a = fgetc(f); // -&gt; &quot;c&quot;

print(&quot;%c %c %c\n&quot;, a, b, c);
</code></pre>
<blockquote>
<p>Saída:</p>
</blockquote>
<pre><code>c a b
</code></pre>
<p>Lembre-se que o fim de um arquivo é demarcado por uma constante chamada de <code>EOF</code> (significa “end of file” ou “fim do arquivo”), logo, se voce usar um loop, para ler o tal arquivo, usem o <code>EOF</code> como “flag”</p>
<blockquote>
<p>“flag” é a condição de interrupção</p>
</blockquote>
<pre><code class="language-c">char caractere;
do {
  caractere = fgetc(arquivo); // -&gt; &lt;caractere&gt; = fgetc(&lt;arquivo&gt;)
  putchar(caractere);
} while (caractere != EOF);
</code></pre>
<p>E depois de terminar de usar, assim como você tem que liberar a memória com o <code>free</code> trabalhando com ponteiros, você tem que fechar o arquivo, ou ele vai ficar ocupando memória à toa</p>
<pre><code class="language-c">fclose(arquivo);
</code></pre>
<p>E ficaria assim:</p>
<pre><code class="language-c">FILE * arquivo;
arquivo = fopen(&quot;j.txt&quot;, &quot;r&quot;);

char caractere;
do {
  caractere = fgetc(arquivo);
  putchar(caractere);
} while (caractere != EOF);
fclose(arquivo);
</code></pre>
<p>Na minha humilde opnião é muito melhor ler os dados caractere por caractere porque assim se tem mais controle dos dados, mas existem outras funções que auxiliam nisso.</p>
<p>O <code>fscanf</code> lê dados do arquivo e joga na variável estipulada:</p>
<pre><code class="language-c">FILE *arquivo = fopen(&quot;texto.txt&quot;, &quot;r&quot;);

char * texto_do_arquivo = malloc(10);
fscanf(arquivo, &quot;%s&quot;, texto_do_arquivo);

printf (&quot;%s&quot;, texto_do_arquivo);

fclose(arquivo);
free(texto_do_arquivo);
</code></pre>
<blockquote>
<p>Não usei a forma de array aqui porque aparentemente o <code>fscanf</code> crachou comigo, mas sinta-se a vontade para testar se isso acontece com você também...</p>
</blockquote>
<p>O <code>fscanf</code> vai ler até o primeiro espaço ou a primeira quebra de linha (<code>\n</code>).</p>
<p>Também dá pra fazer com o já conhecido <code>fgets</code>:</p>
<pre><code class="language-c">FILE *f = fopen(&quot;f.txt&quot;, &quot;r&quot;);

char str [100];
fgets (f, 100, str); // -&gt; fgets ( &lt;arquivo&gt;, &lt;tamanho da string&gt;, &lt;string&gt; )

fclose(f);
</code></pre>
<p>E por fim com o <code>fread</code>, que é uma forma mais direta de ler os dados, mas para usar o <code>fread</code> você tem que saber o limite da leitura ( que no nosso caso é o fim do arquivo), e para descobrir isso, nós vamos usar duas funções chamadas <code>fseek</code> e <code>ftell</code>.</p>
<pre><code class="language-c">fseek(arquivo, 0, SEEK_END); // mudando o &quot;cursor&quot; para o fim do arquivo
size_t tamanho_arquivo = ftell(arquivo); // pegando a posição do cursor
fseek(arquivo, 0, SEEK_SET); // colocando o cursor no inicio de novo
</code></pre>
<p>Feito isso é só ler usando o <code>fread</code></p>
<pre><code class="language-c">fread(      texto,        sizeof (char),              tamanho_arquivo, arquivo );
//   ( &lt;ponteiro&gt;, &lt;tmh do tipo do ptr&gt;, &lt;limite da leitura em bytes&gt;, &lt;arquivo&gt; )
</code></pre>
<p>E vai ficar assim:</p>
<pre><code class="language-c">FILE *arquivo = fopen(&quot;f.txt&quot;, &quot;r&quot;);

fseek(arquivo, 0, SEEK_END); // mudando o &quot;cursor&quot; para o fim do arquivo
size_t tamanho_arquivo = ftell(arquivo); // pegando a posição do cursor
fseek(arquivo, 0, SEEK_SET); // colocando o cursor no inicio de novo

char * texto = malloc( tamanho_arquivo );

fread( texto, sizeof (char), tamanho_arquivo, arquivo );

free(texto);
fclose(arquivo);
</code></pre>
<blockquote>
<p>O conteúdo do arquivo vai ser escrito na variável <code>texto</code></p>
</blockquote>
<h4 id="escrita"><a class="header" href="#escrita">Escrita</a></h4>
<p>Para abrir um arquivo em modo escrita ao invés de colocar o <code>r</code> no parametro do <code>fopen</code>, colocamos um <code>w</code>:</p>
<pre><code class="language-c">FILE *arquivo = fopen(&quot;texto.txt&quot;, &quot;w&quot;);
</code></pre>
<blockquote>
<p>Nesse caso, se o arquivo não existir, ele será criado, mas se existir um arquivo ele perderá todos os seus dados.</p>
</blockquote>
<p>Para escrever um <code>char</code> em um arquivo usamos a função <code>fputc</code></p>
<pre><code class="language-c">fputc('a', arquivo); // -&gt; fputc( &lt;char&gt;, &lt;arquivo&gt; )
</code></pre>
<p>Para escrever uma string use o <code>fputs</code></p>
<pre><code class="language-c">fputs(&quot;string com coisas&quot;, arquivo); // -&gt; fputs(&lt;string&gt;, &lt;arquivo&gt;)
</code></pre>
<p>Ou se quiser escrever um dados formatado use o já estudado <code>fprintf</code></p>
<pre><code class="language-c">fprintf ( arquivo, &quot;%i &gt; %i = %s&quot;, 4, 3, (4 &gt; 3? &quot;True&quot;: &quot;False&quot;));
</code></pre>
<p>E por fim você pode usar o irmão do <code>fread</code>, o <code>fwrite</code>:</p>
<pre><code class="language-c">char texto [] = &quot;texto aleatorio para colocar no arquivo&quot;;
fwrite( texto, sizeof (char), sizeof(texto), arquivo );
</code></pre>
<p>Mas esses não são os únicos modos de abertura de um arquivo</p>
<pre><code class="language-c">&quot;r&quot;  // -&gt; read: somente leitura
&quot;w&quot;  // -&gt; write: somente escrita, mas apaga o conteúdo do arquivo antes de escrever
&quot;a&quot;  // -&gt; append: somente escrita
&quot;r+&quot; // -&gt; read/write: leitura e escrita
&quot;w+&quot; // -&gt; read/write: leitura e escrita, mas apaga o conteúdo do arquivo antes de escrever
&quot;a+&quot; // -&gt; read/append: leitura e escrita
</code></pre>
<blockquote>
<p>Faça seus testes com cada um deles, para ver funcionando na prática</p>
</blockquote>
<p>Você já deve ter percebido que as mesmas funções que usamos em arquivos, são usadas na <code>stdout</code>, <code>stdin</code> e <code>stderr</code>, não é mesmo?
Isuuso acontece, porque essas 3 variáveis são arquivos, e por esse motivo você pode usar todas as funções usadas em arquivos colocando elas no lugar, mas lembre-se, o <code>stdout</code> e o <code>stderr</code> estão em modo <code>&quot;w&quot;</code>, enquanto o <code>stdin</code> está em modo <code>&quot;r&quot;</code>, portanto, você só pode escrever no <code>stdout</code> e no <code>stderr</code>, e só pode ler o <code>stdin</code>. Divirta-se!</p>
<h3 id="posicionamento-em-arquivos"><a class="header" href="#posicionamento-em-arquivos">Posicionamento em arquivos</a></h3>
<p>Para “finalizar” este assunto, existem algumas funções que podem ser úteis na manipulação de arquivos, como o <code>fseek</code> (que já foi visto de maneira superficial)</p>
<blockquote>
<p>Não vamos finalizar totalmente porque ainda faltam algumas funções, que agente vai ver no capítulo de <code>stdarg.h</code></p>
</blockquote>
<pre><code class="language-c">FILE *j = fopen(&quot;j.txt&quot;, &quot;r&quot;);

fseek( j, 0, SEEK_SET); // passa o cursor para o inicio do arquivo
fseek( j, 0, SEEK_CUR); /* passa o cursor para a posição atual do ponteiro
                           se ja tiver lido 3 caracteres, o cursor volta para
                           o caractere 3
                        */
fseek( j, 0, SEEK_END);
</code></pre>
<p>Caso queira retornar para o inicio do arquivo, você pode usar a versão simplificada do <code>fseek</code> que se chama <code>rewind</code></p>
<pre><code class="language-c">FILE * arquivo = open(&quot;j.txt&quot;, &quot;r&quot;);
rewind( arquivo );
</code></pre>
<p>A função <code>ftell</code>, também já vista retorna a posição atual do cursor</p>
<pre><code class="language-c">FILE *j = fopen(&quot;j.txt&quot;, &quot;r&quot;);

char c;
while ((c = fgetc(j)) != 'a')
  putchar(c);

printf(&quot;\n%li\n&quot;, ftell(j));
</code></pre>
<p>Mas caso você precise de mais controle nesse posicionamento é só usar as funções <code>fgetpos</code> e <code>fsetpos</code></p>
<pre><code class="language-c">// j.txt -&gt; &quot;abcdefghijklmnop&quot;
FILE * arquivo = fopen(&quot;j.txt&quot;, &quot;r+&quot;);

fpos_t posicao; // tem que ser deste tipo para funcionar

fgetpos(arquivo, &amp;posicao); // pegando a posição
printf(&quot;posicao: %p\ncaractere: %c&quot;, &amp;posicao, fgetc(arquivo));
fseek( arquivo, 0, SEEK_SET );

fsetpos(arquivo, &amp;posicao + 4); // mudando posição para o 4 caractere
fgetpos(arquivo, &amp;posicao);     // pegando a posição de novo

getchar();

printf(&quot;posicao: %p\ncaractere: %c\n&quot;, &amp;posicao, fgetc(arquivo));
fclose ( arquivo );

getchar();
</code></pre>
<blockquote>
<p>Saída:</p>
</blockquote>
<pre><code>posicao: 0x7ffddf294270
caractere: a
posicao: 0x7ffddf294270
caractere: e
</code></pre>
<h3 id="operações-com-arquivos"><a class="header" href="#operações-com-arquivos">Operações com arquivos</a></h3>
<p>Para apagar o arquivo é só usar a função <code>remove</code></p>
<pre><code class="language-c">remove(&quot;j.txt&quot;);
</code></pre>
<p>E para renomear é só usar <code>rename</code></p>
<pre><code class="language-c">rename(       &quot;j.txt&quot;,  &quot;joao.txt&quot;);
//    ( &lt;nome antigo&gt;, &lt;nome novo&gt;)
</code></pre>
<p>A função <code>reopen</code> é muito útil para mudar o destino de arquivos, exemplo:</p>
<pre><code class="language-c">freopen(&quot;j.txt&quot;, &quot;w&quot;, stdout);
fprintf(&quot;joao é uma pessoa!!\n&quot;, stdout); // o resultado não será impresso na tela, mas no arquivo &quot;j.txt&quot;
</code></pre>
<p>Além de todas essas, lembra de quando imprimimos mensagens na saída de erro (<code>stderr</code>) com <code>fprintf</code>? na <code>stdio.h</code> existe uma que faz isso automaticamente; é o <code>perror</code></p>
<pre><code class="language-c">perror(&quot;ferrou!!&quot;);
</code></pre>
<p>Para outras informações sobre a biblioteca veja a <a href="https://pt.wikibooks.org/wiki/Programar_em_C/Entrada_e_sa%C3%ADda_simples">referência</a> que está no <a href="https://pt.wikibooks.org">wikibooks</a> sobre ela.</p>
<h2 id="stdlibh"><a class="header" href="#stdlibh">stdlib.h</a></h2>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
</code></pre>
<p>A <code>stdlib.h</code> é com certeza uma das bibliotecas mais importantes do C, portanto, merece ser dicecada aqui.</p>
<p>E as funções que já vimos dela foram as de gerenciamento de memória (<code>malloc</code>, <code>free</code>, <code>realloc</code>), logo, não iremos revê-las.</p>
<h3 id="conversões-entre-string-e-outros-tipos"><a class="header" href="#conversões-entre-string-e-outros-tipos">Conversões entre string e outros tipos</a></h3>
<pre><code class="language-c">double     d = atof (&quot;8.9&quot;); // atof(&lt;valor&gt;): de string para double
int        i = atoi (&quot;89&quot;);  // atoi(&lt;valor&gt;): de string para inteiro
long       l = atol (&quot;999&quot;); // atol(&lt;valor&gt;): de string para long
long long ll = atoll (&quot;99&quot;); // atoll(&lt;valor&gt;): de string para long long
</code></pre>
<h3 id="sistema"><a class="header" href="#sistema">Sistema</a></h3>
<p>Caso queira abortar o programa, você pode usar a função <code>exit</code>, e assim como no <code>return</code> do main, você escolhe o valor que quer retornar para o SO</p>
<pre><code class="language-c">int i;

scanf(&quot;%i&quot;, &amp;i);
if (i%2)
  exit(0); // se for impar saia
else
  exit(1); // senao saia e retorne um erro
</code></pre>
<p>Outra função relacionada ao fechamento do programa é a função <code>atexit</code>, que registra funções que serão executadas quando o programa finalizar, sendo que estas funções não podem retornar valores e nem receber parametros.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void tmp_file_remove (void){
  remove(&quot;/tmp/at_exit_lock&quot;);
}

int main(){
  FILE * tmp = fopen(&quot;/tmp/at_exit_lock&quot;, &quot;w&quot;);
  atexit(tmp_file_remove);

  // pausando a execução
  puts(&quot;não click em enter ainda... olhe se há um arquivo \&quot;at_exit_lock\&quot; na pasta /tmp/&quot;);
  getchar();

  puts(&quot;agora veja se ainda está lá&quot;);
  fclose (tmp);
  return 0;
}
</code></pre>
<p>Outra semelhante à <code>atexit</code> é a <code>at_quick_exit</code>, que vai ser executada quando o programa for interromido usando a função <code>quick_exit</code></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void tmp_file_remove (void){
  remove(&quot;/tmp/at_exit_lock&quot;);
}

int main(){
  FILE * tmp = fopen(&quot;/tmp/at_exit_lock&quot;, &quot;w&quot;);
  atexit(tmp_file_remove);

  // pausando a execução
  puts(&quot;não click em enter ainda... olhe se há um arquivo \&quot;at_exit_lock\&quot; na pasta /tmp/&quot;);
  getchar();

  fclose (tmp);
  quick_exit(0);

  // essa parte não vai executar
  puts(&quot;agora veja se ainda está lá&quot;);
  return 0;
}
</code></pre>
<p>Outra variável de sistema muito útil é a <code>getenv</code>, que retorna o valor de uma variável de ambiente.</p>
<pre><code class="language-c">char path = getenv(&quot;PATH&quot;); // caminhos para executáveis no linux ($PATH)
</code></pre>
<p>E as mais úteis de todas, com essas você vai conseguir executar comandos do sistema operacional</p>
<pre><code class="language-c">system( &quot;echo hello mundo!&quot; ); // system( &lt;comando&gt; )
</code></pre>
<p>Mas a <code>system</code> executa e manda o resultado para a <code>stdout</code>, se você quiser acessar o valor de retorno, tem que usar a função <code>popen</code> (que retorna um <code>stream</code>, logo, você vai ter que tratá-la como um arquivo)</p>
<blockquote>
<p>A função popen não funciona no C99, se seu compilador usa C99, não irá compilar.</p>
</blockquote>
<pre><code class="language-c">FILE *response = popen(&quot;echo hello mundo!&quot;, &quot;r&quot;); // popen( &lt;comando&gt; )

char comando [20];
fgets(comando, 20, response);
printf(&quot;o a resposta do comando usado foi:\n%s\n&quot;, comando);
</code></pre>
<p>Ainda faltam algumas funções mas essas são as mais importantes (contando com as de alocamanto de memória),  para outras informações sobre a biblioteca, consulte a <a href="https://pt.wikipedia.org/wiki/Stdlib.h">referência</a> feita por alguém na <a href="http://wikipedia.org/wiki/Stdlib.h">wikipedia</a>.</p>
<h2 id="mathh"><a class="header" href="#mathh">math.h</a></h2>
<pre><code class="language-c">#include &lt;math.h&gt;
</code></pre>
<p>Com certeza toda linguagem que se presa tem uma biblioteca de matemática, a <code>math.h</code> tem diversas funções para resolução de problemas matemáticos desde arredondamento até trigonométricos.</p>
<h3 id="funções-de-arredondamento"><a class="header" href="#funções-de-arredondamento">Funções de arredondamento</a></h3>
<p>Digamos que o valor de uma operação dê <code>1.7</code>, se quisermos arredondá-lo para cima usamos a função <code>ceil</code>:</p>
<pre><code class="language-c">printf(&quot;%f\n&quot;, ceil(1.7));
</code></pre>
<p>Mas se quisermos arredondá-lo para um número menor usamos a função <code>floor</code>:</p>
<pre><code class="language-c">printf(&quot;%f\n&quot;, floor(1.7));
</code></pre>
<p>E se quiser apenas cortar a parte decimal use o <code>trunc</code>:</p>
<pre><code class="language-c">printf(&quot;%f\n&quot;, trunk(1.7));
</code></pre>
<p>Outra opção é arredondar para o número inteiro mais próximo, seja ele acima ou abaixo:</p>
<pre><code class="language-c">printf(&quot;%f\n&quot;, round(1.7));
</code></pre>
<p>A função <code>round</code> tem algumas variações como o <code>lround</code> que arredonda para um <code>long int</code> e o <code>llround</code> que arredonda para um <code>long long int</code>.</p>
<h3 id="potencia-e-radiciação"><a class="header" href="#potencia-e-radiciação">Potencia e radiciação</a></h3>
<p>Para realizar uma potenciação é só usar a função <code>pow</code></p>
<pre><code class="language-c">printf(&quot;40 ao quadrado é %.0f&quot;, pow(40, 2));
</code></pre>
<p>E caso queira fazer uma raiz quadrada é só usar a função <code>sqrt</code></p>
<pre><code class="language-c">float n = pow(40, 2);
printf(&quot;a raiz quadrada de %.0f é %.0f&quot;, n, sqrt(n) );
</code></pre>
<p>E raiz cúbica é <code>cbrt</code></p>
<pre><code class="language-c">float n = pow(40, 3);
printf(&quot;a raiz quadrada de %.0f é %.0f&quot;, n, cbrt(n) );
</code></pre>
<p>E caso você queira fazer uma raiz de índice <code>5</code>, <code>4</code> ou qualquer outro número, lemre-se que uma radiciação é apenas uma potencia elevada à um expoente “ao contrário”:</p>
<blockquote>
<p>2 normal é igual a 2/1, 2 ao contrário é igual a 1/2</p>
</blockquote>
<pre><code class="language-c">// vou usar o expoente 2 mas funciona com qualquer valor
int numero = pow(5, 2);                  // 25
int outro_numero = pow(numero, 1.0/2.0); // 5

printf(&quot;5²  = %i\n√25 = %i\n&quot;, numero, outro_numero);
</code></pre>
<blockquote>
<p>E não esqueça dos <code>.0</code> após o número se você não fizer isso o valor do expoente vai ser um inteiro e portanto, será <code>0</code>, lunca se esqueça de checar os tipos primitivos...</p>
</blockquote>
<p>E existe uma rotina exclusiva para cálculo de hipotenusa:</p>
<pre><code class="language-c">int cateto_oposto = 8, cateto_adjacente = 6;
int hipotenusa = hypot( cateto_oposto, cateto_adjacente );
</code></pre>
<p>A biblioteca de matemática tem diversas outras funções, logo, caso necessite fazer algoritmos matemáticos consulte a <a href="https://www.ufrgs.br/reamat/ComputacaoCientifica/livro/iapcel-a_biblioteca_mathh.html">referência da math.h</a> feita pela <a href="https://www.ufrgs.br">UFRGS</a></p>
<h2 id="stdargh"><a class="header" href="#stdargh">stdarg.h</a></h2>
<pre><code class="language-c">#include &lt;stdarg.h&gt;
</code></pre>
<p>A <code>stdarg.h</code> é uma biblioteca para tratamento de argumentos (ou parametros) de funções.</p>
<p>Até aqui você deve está se perguntando, <em>“como fazer funções como o <code>printf</code> ou o <code>scanf</code> que recebem um número indeterminado de argumentos?”</em>, exatamente usando esta biblioteca, mas preste atenção para entender como você pode usá-la em seus algorítmos.</p>
<p>Para essa biblioteca, vou explicar de uma maneira diferente, aqui nós vamos criar o <code>print</code>, que assim como o <code>printf</code>, irá esquever coisas na tela.</p>
<blockquote>
<p>Como vai ser a chamada do <code>print</code></p>
</blockquote>
<pre><code class="language-c">// print ( &lt;formato&gt;, &lt;dados&gt; );

print( &quot;isfsf&quot;, 90, &quot; + &quot;, 8.3, &quot; = &quot;, 90.0 + 8.3 );

// i -&gt; %i/%d/%li
// s -&gt; %s
// f -&gt; %f/%lf
</code></pre>
<p>Na declaração da função tem que ter pelo menos 1 argumento fixo, e no nosso caso é o <code>formato</code>, todos os outros argumentos serão substituídos por um <code>...</code></p>
<pre><code class="language-c">void print( char * formato, ... );
</code></pre>
<p>Para acessar os dados no <code>...</code> nós primeiro temos que guardar eles em uma variável do tipo <code>va_list</code></p>
<pre><code class="language-c">void print( char * formato, ... ){
  va_list argumentos;
}
</code></pre>
<p>Esse va_list é um ponteiro com todos os argumentos, mas para pegarmos os certos temos que dizer para ele de onde começar a pesquisar usando o <code>va_start</code></p>
<pre><code class="language-c">void print( char * formato, ... ){
  va_list argumentos;
  va_start( argumentos, formato );
}
</code></pre>
<p>Agora iremos checar quantos dados estamos esperando, e depois pegar-los com a função <code>va_arg</code></p>
<blockquote>
<p>Caso for usar valores em <code>char</code>, na hora de usar o <code>va_arg</code>, usem com <code>int</code>, ele não aceita <code>char</code> porque é muito pequeno.</p>
</blockquote>
<pre><code class="language-c">#include &lt;string.h&gt; // -&gt; strlen
void print( char * formato, ... ){
  va_list argumentos;
  va_start( argumentos, formato );

  int argc = strlen(formato); // pegando a qntd de caracteres da string

  for (int i = 0; i&lt;argc; i ++){
    if (formato[ i ] == 'i') // caso o dado esperado for um int
      printf( &quot;%li&quot;, va_arg( argumentos,      long int ) );
      //             va_arg( &lt;lista de args&gt;,   &lt;tipo&gt; ) );

    if (formato[ i ] == 'f') // float
      printf( &quot;%lf&quot;, va_arg( argumentos, double ) );

    if (formato[ i ] == 's') // string
      printf(va_arg( argumentos, char *));
  }
  putchar('\n');
  va_end( argumentos ); // fechando os argumentos
}
</code></pre>
<blockquote>
<p>O <code>va_arg</code>, assim como o <code>fgetf</code>, retorna o dado e passa para o próximo automaticamente.</p>
</blockquote>
<p>E fim, essas são as únicas funções que existem nessa biblioteca. Mas como eu prometi no capítulo sobre <code>stdio.h</code> agora eu irei explicar sobre as funções que usam o <code>va_list</code> da <code>stdarg.h</code></p>
<p>As funções do <code>stdio.h</code> que usam <code>va_list</code> fazem o mesmo que as outras, só que aceitam esse tipo de argumento, como o <code>vprintf</code></p>
<pre><code class="language-c">void escreva_numeros ( int qntd, ... ){
  va_list args;
  va_start( args, qntd );

  char * formato = malloc( qnt*3+1 );
  for (int i=0; i&lt;qntd; i+=2){
    formato[i] = '%';
    formato[i+1] = 'i';
    formato[i+2] = 'i';
  }
  formato[ qnt*3 ] = '\n';

  vprintf(formato, args);

  va_end( args );
  free(formato);
}
</code></pre>
<p>E funciona da mesma maneira com as funções <code>vscanf</code> (<code>scanf</code>), <code>vsscanf</code> (<code>sscanf</code>), <code>vfscanf</code> (<code>fscanf</code>) ...</p>
<h2 id="stringh"><a class="header" href="#stringh">string.h</a></h2>
<pre><code class="language-c">#include &lt;string.h&gt;
</code></pre>
<p>Esta é mais uma das bibliotecas que eu já falei, mas não me aprofundei, portanto irei ignorar as funções já mencionadas (<code>strlen</code>, <code>strcpy</code>).</p>
<p>A primeira função interessante é a <code>strncpy</code>, que ao invés de copiar a string inteira, copia apenas um número de caracteres</p>
<pre><code class="language-c">char str[10];
strncpy(str, &quot;joao e maria&quot;, 4); // copia até o 4 caractere
str[4] = '\0';                   // setando o fim da string

puts(str);
</code></pre>
<blockquote>
<p>Saída:</p>
</blockquote>
<pre><code>joao
</code></pre>
<p>Outra que também é bacana é a <code>strcat</code>, que serve para concatenar strings</p>
<pre><code class="language-c">char str[] = &quot;joao&quot;;
strcat(str, &quot; e maria&quot;); // strcat( &lt;destino&gt;, &lt;destinatario&gt; );
</code></pre>
<p>E existe a variação <code>strncat</code>, que concatena até um certo número de caracteres</p>
<pre><code class="language-c">char str[] = &quot;joao&quot;;
strncat(str, &quot; e maria rosa&quot;, 8);
</code></pre>
<p>Uma função muito útil dessa biblioteca é a <code>strcmp</code> que compara duas strings</p>
<pre><code class="language-c">char str [] = &quot;joao&quot;, str2 [] = &quot;maria&quot;;
int res = strcmp( str, str2 ); // strcmp( &lt;str&gt;, &lt;str2&gt; )

if ( res == 0 )
  puts(&quot;as strings são iguais&quot;);
else if ( res &lt; 0 )
  puts(&quot;\&quot;%s\&quot; é menor que \&quot;%s\&quot;&quot;, str, str2);
else if ( res &gt; 0 )
  puts(&quot;\&quot;%s\&quot; é maior que \&quot;%s\&quot;&quot;, str, str2);
</code></pre>
<p>E também existe a <code>strncmp</code> que funciona da mesma forma que a anterior, mas compara só até um certo caractere.</p>
<pre><code class="language-c">char str [] = &quot;joao&quot;, str2 [] = &quot;joao e maria&quot;;
int res = strncmp( str, str2, 4 ); // strncmp( &lt;str&gt;, &lt;str2&gt;, &lt;numero&gt; )

if (res == 0)
  puts(&quot;os primeiros 4 caracteres da string 2 são iguais aos da string 1&quot;);
</code></pre>
<p>Outras opções são usar funções de pesquisa em strings, como o <code>strchr</code> que irá retornar um ponteiro para a primeira ocorrencia de um caractere</p>
<pre><code class="language-c">char j[] = &quot;abcdefghijklmnop;joao\0&quot;;
puts(strchr(j, 'g'));
puts(strchr(j, ';')+1);

char * f = strchr(j, ';');
* f = '\0'; /* finalizando a string
               na primeira ocorrencia
               de &quot;;&quot; */

puts(j);
</code></pre>
<blockquote>
<p>Saída:</p>
</blockquote>
<pre><code>ghijklmnop;joao
joao
abcdefghijklmnop
</code></pre>
<p>Outra bem bacana é a <code>strcspn</code> onde você passa uma certa lista de caracteres e ela irá retornar a primeira ocorrencia de qualquer caractere da lista</p>
<pre><code class="language-c">char str[] = &quot;bcdefgh&quot;;
printf(&quot;A vogal \&quot;%c\&quot; está na %iª posição de \&quot;%s\&quot;\n&quot;,
    str[ strcspn(str, &quot;aeiou&quot;) ], strcspn(str, &quot;aeiou&quot;)+1, str);
</code></pre>
<blockquote>
<p>Saída:</p>
</blockquote>
<pre><code>A vogal &quot;e&quot; está na 4ª posição de &quot;bcdefgh&quot;
</code></pre>
<p>Uma semelhante a <code>strchr</code> é a <code>strstr</code>, que retorna a string da primeira ocorrencia de um caractere até o seu fim</p>
<pre><code class="language-c">char str[] = &quot;joao maria ronaldo&quot;;
puts(strstr(str, &quot;maria&quot;));
</code></pre>
<h2 id="ctypeh"><a class="header" href="#ctypeh">ctype.h</a></h2>
<pre><code class="language-c">#include &lt;ctype.h&gt;
</code></pre>
<p>Esta biblioteca possui funções para reconhecimento de tipos de caractere (<code>char</code>), e carrega diversas funções para esse reconhecimento.</p>
<pre><code class="language-c">isnum    ('2'); // se é numerico
isalpha  ('s'); // se é alfabético
isblank ('\t'); // se é vazio
iscntrl ('\n'); // se é caractere especial
isdigit  ('4'); // se é numero decimal
isgraph  ('!'); // se tem representação gráfica
isprint  ('2'); // se dá para escrever na tela
ispunct  ('.'); // se é pontuação
isspace ('\v'); // se é um espaço branco
isxdigit ('0'); // se é hexadecimal
islower  ('a'); // se é letra minúscula
isupper  ('A'); // se é letra maiúscula

tolower  ('A'); // transforma em letra minúscula
toupper  ('a'); // transforma em letra maiúscula
</code></pre>
<p>É necessário que eu esclareça alguns pontos, caracteres como <code></code> ou <code>ç</code> são grandes demais para caber em um <code>char</code>, caso precise desses caracteres unicode, use strings para representá-los.</p>
<h2 id="conioh"><a class="header" href="#conioh">conio.h</a></h2>
<pre><code class="language-c">#include &lt;conio.h&gt;
</code></pre>
<p>Esta é uma biblioteca exclusiva para sistemas baseados em <a href="https://pt.wikipedia.org/wiki/MS-DOS">MS-DOS</a>, como o windows, ou o <a href="https://pt.wikipedia.org/wiki/ReactOS">reactOS</a>, e serve para a entrada e saída de dados com o console.</p>
<p>A função mais interessante é sem dúvidas a <code>getch</code>, que basicamente espera um caractere.</p>
<pre><code class="language-c">char c;

printf(&quot;digite um caractere&quot;);
c = getch();
</code></pre>
<blockquote>
<p>Ele não espera um “enter”, ele apenas recebe o caractere e pronto.</p>
</blockquote>
<p>Outra forma legal de usar esta função é pra controlar a entrada do usuário, por exemplo, quero ler um texto eternamente e parar quando a pessoa clicar na tecla <kbd>esc</kbd>.</p>
<pre><code class="language-c">#include &lt;conio.h&gt;
#include &lt;stdio.h&gt;

int main(){
    puts(&quot;digite coisas aqui:&quot;);

    char c, *str = malloc(1);
    int i = 0;
    while ((c = getch()) != 27){ /* enquanto o caractere lido
                                    for diferente da
                                    tecla &lt;ESC&gt;
                                 */
        putchar(c);
        str = realloc(str, sizeof str + sizeof c);
        str[i++] = c;
    }

    printf(&quot;\n%s\n&quot;, str);
    free(str);
    return 0;
}
</code></pre>
<p>Bom, basicamente é isso, todas as outras funções são apenas alternativas a já existentes como o <code>cgets</code> que funciona igual a <code>gets</code> do <code>stdio.h</code>, ou a <code>cprintf</code>... enfim.</p>
<h1 id="considerações-finais"><a class="header" href="#considerações-finais">Considerações finais</a></h1>
<p>Espero que este livro tenha ajudado você, este não é o fim definitivo, os seus estudos não devem acabar aqui, então tenha paciência e antes de ir embora vou da um bônus para você se animar e começar seus projetos em C.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="13-hello-world-grafico.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="13-hello-world-grafico.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
