<!DOCTYPE HTML>
<html lang="pt" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>C Para Seres Humanos</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="0-sobre.html"><strong aria-hidden="true">1.</strong> Sobre</a></li><li class="chapter-item expanded "><a href="1-nocoes-basicas.html"><strong aria-hidden="true">2.</strong> Nocoes basicas</a></li><li class="chapter-item expanded "><a href="2-introducao-a-sintaxe-do-c.html"><strong aria-hidden="true">3.</strong> Introducao a sintaxe do C</a></li><li class="chapter-item expanded "><a href="3-conceitos-interessantes.html"><strong aria-hidden="true">4.</strong> Conceitos interessantes</a></li><li class="chapter-item expanded "><a href="4-entrada-e-saida-de-dados.html"><strong aria-hidden="true">5.</strong> Entrada e saida de dados</a></li><li class="chapter-item expanded "><a href="5-operadores.html"><strong aria-hidden="true">6.</strong> Operadores</a></li><li class="chapter-item expanded "><a href="6-arrays-e-strings.html"><strong aria-hidden="true">7.</strong> Arrays e Strings</a></li><li class="chapter-item expanded "><a href="7-escopo-e-condicionais.html"><strong aria-hidden="true">8.</strong> Escopo e Condicionais</a></li><li class="chapter-item expanded "><a href="8-estruturas-de-repeticao.html"><strong aria-hidden="true">9.</strong> Estruturas de repeticao</a></li><li class="chapter-item expanded "><a href="9-funcoes.html"><strong aria-hidden="true">10.</strong> Funcoes</a></li><li class="chapter-item expanded "><a href="9-ponteiros.html"><strong aria-hidden="true">11.</strong> Ponteiros</a></li><li class="chapter-item expanded "><a href="10-customizacao-de-tipos.html"><strong aria-hidden="true">12.</strong> Customizacao de tipos</a></li><li class="chapter-item expanded "><a href="11-hacks-e-extras.html"><strong aria-hidden="true">13.</strong> Hacks e Extras</a></li><li class="chapter-item expanded "><a href="13-hello-world-grafico.html"><strong aria-hidden="true">14.</strong> Hello World Grafico</a></li><li class="chapter-item expanded "><a href="14-bibliotecas-uteis.html"><strong aria-hidden="true">15.</strong> Bibliotecas uteis</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">C Para Seres Humanos</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/plankiton/CParaSeresHumanos" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="sobre-o-autor"><a class="header" href="#sobre-o-autor">Sobre o autor</a></h1>
<center>
<img
   alt="Yaks Souza's Photo (plankiton - pl4nk1ton@gmail.com)"
   src="https://avatars.githubusercontent.com/u/39075126?v=4"
   style="border-radius: 50%; margin: 10px; max-width: 300px;"
/>
</center>
<p>Eu sou Yak‚Äôs Vinicios Silva Souza, sou um entusiasta de tecnologia e por isso resolvi expor um pouco do meu conhecimento neste livro.</p>
<ul>
<li><a href="https://pl4nk1ton.medium.com">Blog</a> - pl4nk1ton.medium.com</li>
<li><a href="https://instagram.com/plank1ton">Instagram</a> - @plank1ton</li>
<li><a href="https://www.linkedin.com/in/plankiton">LinkedIn</a> - /in/plankiton</li>
<li><a href="https://github.com/Plankiton">GitHub</a> - /Plankiton</li>
</ul>
<h1 id="sobre-o-livro"><a class="header" href="#sobre-o-livro">Sobre o livro</a></h1>
<center>
<img
   src="https://raw.githubusercontent.com/Plankiton/CParaSeresHumanos/master/assets/icon.png"
   style="border-radius: 50px;"
/>
</center>
<p>Antes de come√ßar, este livro √© destinado a iniciantes no mundo da programa√ß√£o, por isso todos os termos apresentados aqui est√£o sendo explicados da forma mais simples poss√≠vel, mas os conhecimentos aqui apresentados ir√£o atender qualquer iniciante em linguagem C (mesmo que voc√™ j√° saiba programar em outra linguagem).</p>
<p>Por favor, se voc√™ encontrar qualquer erro ortogr√°fico ou em rela√ß√£o aos conhecimentos apresentados, envie-me um email avisando, ou fa√ßa um pull-request no <a href="http://github.com/Plankiton/cparasereshumanos">reposit√≥rio do livro</a></p>
<ul>
<li><a href="https://apoia.se/cparasereshumanos">apoia.se</a> - cparasereshumanos (doe para o projeto)</li>
<li><a href="https://github.com/Plankiton/CParaSeresHumanos">github</a> - Plankiton/CParaSeresHumanos (contribua para o projeto)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="no√ß√µes-b√°sicas"><a class="header" href="#no√ß√µes-b√°sicas">No√ß√µes b√°sicas</a></h1>
<h2 id="o-que-√©-c"><a class="header" href="#o-que-√©-c">O que √© ‚ÄúC‚Äù?</a></h2>
<p>C √© uma linguagem de programa√ß√£o, algo que usamos para ‚Äúfalar com o computador‚Äù. Voc√™ escreve o que quer que ele fa√ßa em um arquivo e ele vai fazer, e o C √© s√≥ uma forma de se fazer isso. Existe uma infinidade de linguagens por a√≠, mas eu estou aqui para lhes mostrar essa que √© considerada por muitos uma das melhores linguagens de todos os tempos, e eu estou sendo inserido nesse ‚Äúmuitos‚Äù.</p>
<p><img
   align="right"
   style="border-radius: 10px; margin: 10px; max-height: 150px;"
   src="https://i.pinimg.com/564x/ab/55/d7/ab55d772ae879cc095b040a098ce8dd6.jpg"
/></p>
<blockquote>
<p>O C simplesmente n√£o ter nenhum simbolo (al√©m de um C gen√©rico) ou mascote pra gente poder tatuar na pele e dizer ‚Äúeu amo C‚Äù, ent√£o fica a√≠ minha sugest√£o pra comunidade (e tem que ser um dinossauro):</p>
<p>Lhes apresento o clancy</p>
<ul>
<li>Ilustrator: Cris Ryniak</li>
</ul>
</blockquote>
<h2 id="como-o-c-funciona"><a class="header" href="#como-o-c-funciona">Como o C funciona?</a></h2>
<p>O C √© uma linguagem compilada...</p>
<blockquote>
<p>Basicamente, significa que um programa traduz o que voc√™ escreve em um arquivo para uma liguagem que s√≥ o computador entende.</p>
</blockquote>
<p>E √© considerado por muitos uma linguagem de <em>m√©dio n√≠vel</em> (alguns o consideram uma linguagem de <em>baixo n√≠vel</em>), e com isso n√£o estou referindo-me √† qualidade do C, mas ao n√≠vel de proximidade com o hardware (a parte f√≠sica do computador). Quanto mais pr√≥ximo do hardware, mais baixo √© o n√≠vel e essa caracter√≠stica do C o torna a linguagem mais indicada para fazer aplica√ß√µes de sistema (programas que manipulam o hardware) e aplica√ß√µes gr√°ficas (jogos, editores de imagem...).</p>
<blockquote>
<p>S√≥ para deixar claro o C √© uma linguagem de alto n√≠vel, o fato de usarmos simbolos e palavras humanas de uma forma simplificada √© o que define baixo e alto n√≠vel, mas por ter tanta intimidade com o hardware, as pessoas come√ßaram a consider√°-lo em um n√≠vel mais baixo.</p>
</blockquote>
<p>S√≥ para se ter uma ideia do poder do C, vou listar alguns <em>softwares</em> feitos nessa linguagem:</p>
<blockquote>
<p>Todos os softwares listados s√£o <strong>open source</strong>, dessa forma voc√™s podem ter certeza de que foi mesmo feito em C, al√©m de poderem editar o c√≥digo, se quiserem...</p>
</blockquote>
<ol>
<li><a href="https://blender.org">Blender</a>                - Modelador 3D e engine de jogos.</li>
<li><a href="https://kernel.org">Linux</a>                   - N√∫cleo das distribui√ß√µes linux.</li>
<li><a href="httsp://gimp.org">Gimp</a>                      - Editor de imagens.</li>
<li><a href="https://github.com/apple/darwin-xnu">Darwin</a> - N√∫cleo do Mac OS X</li>
<li><a href="https://www.videolan.org/vlc/">VLC</a>          - Reprodutor de V√≠deos</li>
</ol>
<h2 id="qual-√©-a-hist√≥ria-do-c"><a class="header" href="#qual-√©-a-hist√≥ria-do-c">Qual √© a hist√≥ria do C?</a></h2>
<p><img
   alt="Dennis ritchie and ken thompson 1973"
   align="right"
   style="border-radius: 10px; margin: 10px; max-height: 200px;"
   src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/Ken_Thompson_and_Dennis_Ritchie--1973.jpg/500px-Ken_Thompson_and_Dennis_Ritchie--1973.jpg"
/></p>
<p>Resumidamente, o C foi criado na d√©cada de 1970 por <a href="https://pt.wikipedia.org/wiki/Ken_Thompson">Ken Thompson</a> e <a href="https://pt.wikipedia.org/wiki/Dennis_Ritchie">Dennis Ritchie</a> para reprogramar o <a href="https://pt.wikipedia.org/wiki/Unix">UNIX</a>, que era escrito em <a href="https://pt.wikipedia.org/wiki/Linguagem_assembly">assembly</a>.</p>
<p>O C √© uma evolu√ß√£o da linguagem <a href="https://pt.wikipedia.org/wiki/B_(linguagem_de_programa%C3%A7%C3%A3o)">B</a> que foi influenciada pela linguagem <a href="https://pt.wikipedia.org/wiki/BCPL">BCPL</a>. No in√≠cio, a linguagem C era despadronizada, isso significa que cada compilador de C usava uma <em>‚Äúvers√£o‚Äù</em> diferente, ent√£o, em 1983 a <a href="https://pt.wikipedia.org/wiki/American_National_Standards_Institute">ANSI</a> resolveu padronizar o C para que ele funcionasse mais coerentemente em compiladores diferentes, e n√£o foi s√≥ a ANSI que padronizou, a <a href="https://pt.wikipedia.org/wiki/ISO">ISO</a> tamb√©m j√° fez isso.</p>
<h2 id="como-se-instala-o-tal-compilador-c"><a class="header" href="#como-se-instala-o-tal-compilador-c">Como se instala o tal ‚Äúcompilador‚Äù C?</a></h2>
<p>Neste cap√≠tulo vou demonstrar a instala√ß√£o em alguns sistemas operacionais, mas todos os exemplos do livro foram testados em um sistema linux, ent√£o para garantir que tudo vai funcionar perfeitamente eu aconselho que seja lido e testado em um sistema linux (mesmo que seja uma m√°quina virtual).</p>
<h3 id="gnu-c-collection"><a class="header" href="#gnu-c-collection">GNU C Collection</a></h3>
<p>O <a href="https://pt.wikipedia.org/wiki/GNU_Compiler_Collection">gcc</a>, j√° vem com uma gama de ferramentas j√° inclusas, como o compilador C (<code>gcc</code>) e o compilador C++ (<code>g++</code>).</p>
<p>Se voc√™ usa uma distribui√ß√£o Linux ou BSD, provavelmente j√° est√° instalado, mas, caso n√£o esteja (o que eu duvido muito), √© s√≥ usar o gerenciador de pacotes para instalar.</p>
<h4 id="debian"><a class="header" href="#debian">Debian</a></h4>
<pre><code class="language-sh">sudo apt install gcc
</code></pre>
<h4 id="red-hat"><a class="header" href="#red-hat">Red Hat</a></h4>
<pre><code class="language-sh">sudo dnf install gcc
sudo yum install gcc
</code></pre>
<h4 id="arch-linux"><a class="header" href="#arch-linux">Arch Linux</a></h4>
<pre><code class="language-sh">sudo pacman -S gcc
</code></pre>
<h4 id="mac-os-x"><a class="header" href="#mac-os-x">Mac OS X</a></h4>
<p>Se voc√™ n√£o tem <a href="https://brew.sh/index_pt-br">homebrew</a>, rode:</p>
<pre><code class="language-sh">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre>
<blockquote>
<p>Instalando gcc:</p>
</blockquote>
<pre><code class="language-sh">brew install gcc
</code></pre>
<h4 id="windows"><a class="header" href="#windows">Windows</a></h4>
<p>Se voc√™ n√£o tem o <a href="https://chocolatey.org/">chocolatey</a>, rode no <strong><a href="https://pt.wikipedia.org/wiki/PowerShell">PowerShell</a> em modo administrador</strong>:</p>
<pre><code class="language-PS1">Set-ExecutionPolicy Bypass -Scope Process -Force
iex((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))
</code></pre>
<blockquote>
<p>Instalando gcc</p>
</blockquote>
<pre><code class="language-bat">choco install mingw -y
</code></pre>
<h3 id="tiny-c-compiler"><a class="header" href="#tiny-c-compiler">Tiny C Compiler</a></h3>
<p>Uma outra op√ß√£o de compilador muito interessante √© o <a href="https://en.wikipedia.org/wiki/Tiny_C_Compiler">tcc</a> √© um compilador independente com o int√∫ito de gerar c√≥digos pequenos, mas n√£o √© recomendado para aplica√ß√µes grandes, mas para estudo √© uma √≥tima op√ß√£o.</p>
<h4 id="debian-1"><a class="header" href="#debian-1">Debian</a></h4>
<pre><code class="language-sh">sudo apt install tcc
</code></pre>
<h4 id="red-hat-1"><a class="header" href="#red-hat-1">Red Hat</a></h4>
<pre><code class="language-sh">sudo dnf install tcc
sudo yum install tcc
</code></pre>
<h4 id="arch-linux-1"><a class="header" href="#arch-linux-1">Arch Linux</a></h4>
<pre><code class="language-sh">sudo pacman -S tcc
</code></pre>
<h4 id="mac-os-x-1"><a class="header" href="#mac-os-x-1">Mac OS X</a></h4>
<pre><code class="language-sh">brew install tcc
</code></pre>
<h4 id="windows-1"><a class="header" href="#windows-1">Windows</a></h4>
<pre><code class="language-sh">choco install tcc
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introdu√ß√£o-√†-sintaxe-do-c"><a class="header" href="#introdu√ß√£o-√†-sintaxe-do-c">Introdu√ß√£o √† sintaxe do C</a></h1>
<h3 id="hello-mundo-em-c"><a class="header" href="#hello-mundo-em-c">Hello mundo em C</a></h3>
<blockquote>
<p>Hello_mundo.c</p>
</blockquote>
<pre><code class="language-c">#include &lt;stdio.h&gt;            // importa√ß√£o de biblioteca externa

int main () {                 // declara√ß√£o da fun√ß√£o main
   printf(&quot;Hello mundo!!\n&quot;); // fun√ß√£o que escreve coisas na tela
   return 0;                  // retorno da fun√ß√£o
}                             // fim da fun√ß√£o
</code></pre>
<p>Compilando o arquivo</p>
<blockquote>
<p>linux/BSD/Mac OSX</p>
</blockquote>
<pre><code class="language-sh">gcc Hello_mundo.c -o hello
</code></pre>
<blockquote>
<p>Windows</p>
</blockquote>
<pre><code class="language-bat">gcc Hello_mundo.c -o hello.exe
</code></pre>
<p>Todos os exemplos e desafios s√£o compilados da mesma forma: <code>gcc &lt;arquivo.c&gt; -o &lt;nome do bin√°rio&gt;</code></p>
<blockquote>
<p>Caso o arquivo n√£o compile com o <code>gcc</code> use o <code>g++</code></p>
</blockquote>
<p>Executando o arquivo (lembre-se de estar no mesmo diret√≥rio do arquivo compilado)</p>
<blockquote>
<p>linux/BSD/Mac OS X</p>
</blockquote>
<pre><code class="language-sh">./hello
</code></pre>
<blockquote>
<p>Windows</p>
</blockquote>
<pre><code class="language-bat">hello.exe
</code></pre>
<blockquote>
<p>Sa√≠da</p>
</blockquote>
<pre><code>Hello mundo!!
</code></pre>
<blockquote>
</blockquote>
<blockquote>
<p>Todos os exemplos e desafios s√£o executados da mesma forma mostrada acima, apenas troque o <code>hello</code> pelo nome do bin√°rio gerado.</p>
</blockquote>
<p>No programa apresentado, n√≥s vimos a estrutura b√°sica de todo programa em C, no qual temos a importa√ß√£o do m√≥dulo <code>stdio.h</code> (conjunto de fun√ß√µes para sa√≠da e entrada de dados), a fun√ß√£o <code>main</code>(fun√ß√£o que √© chamada na execu√ß√£o do programa), e os comandos da fun√ß√£o que ser√£o executados (tudo o que est√° entre <code>{</code> e <code>}</code>), que no nosso caso √© o <code>printf</code>(fun√ß√£o de sa√≠da de dados que escreve texto na tela), e por fim o <code>return</code> que diz para o sistema operacional se ocorreu tudo como o planejado na execu√ß√£o da fun√ß√£o <code>main</code>.</p>
<blockquote>
<p>Notem que todos os comandos dentro do bloco (tudo o que est√° entre <code>{</code> e <code>}</code>) da fun√ß√£o <code>main</code> est√£o separados por <code>;</code>, caso voc√™ se esque√ßa desse caractere, o seu programa n√£o ser√° compilado.</p>
</blockquote>
<p>A fun√ß√£o <code>main</code> √© essencial para o funcionamento de programas escritos em C, pois ela √© a fun√ß√£o que √© chamada na execu√ß√£o do programa.</p>
<p>Mas, caso voc√™ ainda n√£o tenha entendido, eu vou explicar de uma maneira mais simples.</p>
<p><img
   src="https://i.imgur.com/EwCdzI8.png"
   style="border-radius: 10px; margin: 10px; max-height: 200px;"
   alt="a frigideira da Terezinha"
   align="right"
/></p>
<blockquote>
<p>Imagine que Terezinha, uma cozinheira muito habilidosa, vai preparar um ovo frito.</p>
<p>A primeira coisa que ela faz √© pegar uma frigideira com √≥leo e colocar no fogo. Depois, ela vai quebrar o ovo dentro da frigideira e jogar sal. Depois de todos os passos feitos ela d√° uma olhada para saber se o ovo queimou, ou se tudo ocorreu como desejado.</p>
</blockquote>
<p>Terezinha simboliza o sistema operacional executando um programa feito em C. a frigideira √© a fun√ß√£o <code>main</code>, a fritura do ovo √© executada pela frigideira.</p>
<p>Terezinha sabe se o ovo est√° queimado ou n√£o porque a frigideira d√° um retorno (quando o ovo est√° mais escuro, ela sabe que queimou): esse √© o papel do comando <code>return</code> da fun√ß√£o <code>main</code>.</p>
<blockquote>
<p>A partir daqui, voc√™ vai se deparar com diversos c√≥digos soltos (para economizar espa√ßo), mas quando for test√°-los na sua m√°quina, coloque-os dentro da fun√ß√£o <code>main</code>:</p>
</blockquote>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(){
   &lt;comandos apresentados&gt;
   return 0;
}
</code></pre>
<p>O <code>;</code> √© o que delimita o fim de um comando no C e ele ignora os espa√ßos ou quebras de linha em excesso antes do <code>;</code>, logo, isso:</p>
<pre><code class="language-c">           printf
(
&quot;Hello mundo!!\n&quot;
         )
;
</code></pre>
<p>√â o mesmo que isso:</p>
<pre><code class="language-c">printf(&quot;Hello mundo!!\n&quot;);
</code></pre>
<blockquote>
<p>Ent√£o as regras para o uso do <code>;</code> s√£o:</p>
<ol>
<li>Devem estar no final das linhas com comandos.</li>
<li>N√£o devem estar em linhas que come√ßarem com <code>#</code>.</li>
<li>N√£o devem estar em linhas que terminam com chaves se essas chaves pertencem a blocos de c√≥digo (pois existem outras estruturas que usam chaves).</li>
</ol>
</blockquote>
<p>Mas mesmo sabendo disso tome cuidado com os espa√ßos, pois em alguns casos muito espec√≠ficos a falta deles pode confundir o compilador, por exemplo:</p>
<pre><code class="language-c">int i = -2 - -3;
</code></pre>
<blockquote>
<p>n√£o se preocupe com o <code>int i =</code>, saiba apenas que <code>i</code> √© uma vari√°vel, isso ser√° explicado mais tarde...</p>
</blockquote>
<p>O <code>-3</code> √© um n√∫mero negativo, mas o <code>-</code> entre <code>-2</code> e <code>-3</code> √© o sinal de subtra√ß√£o, se n√£o houvesse espa√ßo entre o <code>-</code> solto e os outros n√∫meros, o programa acima n√£o seria compilado pois o C n√£o saberia o que voc√™ quer que ele fa√ßa.</p>
<h2 id="coment√°rios"><a class="header" href="#coment√°rios">Coment√°rios</a></h2>
<p>Coment√°rios s√£o ‚Äúanota√ß√µes ou esclarecimentos‚Äù escritas(os) no c√≥digo para descrever a fun√ß√£o de algo e geralmente s√£o √∫teis quando se  quer analisar algum c√≥digo antigo seu, ou o c√≥digo de outra pessoa. Os coment√°rios sempre s√£o ignorados pelo compilador, eles s√£o apenas para auxiliar o programador.</p>
<pre><code class="language-c">// coment√°rios de uma √∫nica linha
/*
   coment√°rios 
   de 
   multiplas 
   linhas
*/
</code></pre>
<p>√â sempre aconselh√°vel o uso de coment√°rios, principalmente se voc√™ pretende fazer um projeto <em>open source</em> (como j√° dito, projetos de c√≥digo aberto).</p>
<h2 id="vari√°veis"><a class="header" href="#vari√°veis">Vari√°veis</a></h2>
<p><img
   style="border-radius: 10px; margin: 10px; max-height: 200px;"
   src="https://i.imgur.com/4pIW8iB.png"
   align="right"
/></p>
<blockquote>
<p>Imagine um arm√°rio com diversos espa√ßos com um nome para identificar, alguns s√≥ cabem esferas e outros s√≥ cabem cubos.
Toda vez que algu√©m quer um espa√ßo no arm√°rio deve  pedir para o dono, mas o dono s√≥ reserva o espa√ßo se pedir da maneira correta, que √©:</p>
<p><code>&lt;tipo do espa√ßo&gt; &lt;nome do espa√ßo&gt; com &lt;coisa&gt; dentro</code></p>
<p>Exemplos:</p>
<p><code>esfera bola_de_futebol com ‚öΩ dentro</code></p>
<p><code>cubo   dado           com üé≤ dentro</code></p>
</blockquote>
<p>O arm√°rio √© a mem√≥ria do seu computador, os espa√ßos s√£o as vari√°veis e o nome em cada espa√ßo √© o nome da vari√°vel, que s√≥ consegue armazenar tipos espec√≠ficos de dados, no exemplo s√£o <code>esfera</code>, <code>cubo</code> ou <code>boneca</code>, e a situa√ß√£o descrita para a reserva de um espa√ßo √© a declara√ß√£o:</p>
<pre><code class="language-c">// &lt;tipo do espa√ßo&gt;  &lt;nome do espa√ßo&gt;    &lt;dado&gt;
   int               numero            =    80;
</code></pre>
<p>No exemplo acima, reservei um espa√ßo que s√≥ guarda n√∫meros inteiros (<code>int</code>) com o nome <code>numero</code> e com o valor <code>80</code> dentro. E no C, existem 3 tipos primitivos, ou seja, 3 tipos de dados b√°sicos, o <code>int</code>, o <code>float</code> e o <code>char</code>.</p>
<pre><code class="language-c">   int   numero      = 80;
   char  caractere   = 'A';
   float numero_real = 99.9;
</code></pre>
<p>Vari√°veis do tipo <code>int</code> recebem n√∫meros sem ponto, como <code>2</code>, <code>8</code> ou <code>234</code> enquanto as do tipo <code>float</code> recebem n√∫meros com ponto como <code>2.5</code>, <code>8.3</code> ou <code>23.0</code>, j√° vari√°veis do tipo <code>char</code> recebem um caractere, <strong>apenas um</strong> , logo, se tentar colocar um <code>&quot;hello&quot;</code> ou at√© mesmo um <code>&quot;h&quot;</code>, ele vai retornar um erro, pois todo e qualquer caractere entre <code>&quot;</code> √© uma string enquanto um <code>char</code> √© um √∫nico caractere entre <code>'</code>, n√£o se preocupe com as strings, por enquanto...</p>
<p>E se voc√™ deseja alterar o valor da vari√°vel, s√≥ precisa colocar o nome da vari√°vel recebendo o valor:</p>
<pre><code class="language-c">int i = 5; // declara√ß√£o da vari√°vel &quot;i&quot; valendo &quot;5&quot;

i = 92;    // agora a vari√°vel vale 92
</code></pre>
<p>Esse exemplo acima serve para todos os tipos primitivos, mas lembre-se de colocar valores do tipo certo na vari√°vel. Se voc√™ declarou uma vari√°vel inteira, na hora de alterar o valor, tem que trocar por um inteiro.</p>
<p>Al√©m disso, tamb√©m existe o tipo <code>double</code> que √© descendente do tipo <code>float</code>, mas com mais capacidade de espa√ßo... <em>‚ÄúMas como assim espa√ßo? N√∫meros n√£o s√£o infinitos?‚Äù</em> ... Os n√∫meros s√£o infinitos sim, mas a mem√≥ria ram do computador n√£o √©, e mesmo que fosse, seria um desperd√≠cio liberar um espa√ßo infinito para uma √∫nica vari√°vel, ent√£o todas as vari√°veis dentro do C tem um espa√ßo limitado.</p>
<p>Cada vari√°vel ocupa uma certa quantidade de bytes na mem√≥ria ram:</p>
<pre><code class="language-c">/*
um byte tem 8 bites e um bite s√≥ pode ser 0 ou 1, isso quer dizer que 
sempre que o computador reserva 1 byte ele est√° reservando 8 espacinhos
com zeros e ums.
*/

int inteiro = 0; /* -&gt; 4 bytes -&gt; voc√™ s√≥ consegue colocar 
                       n√∫meros de -2147483648 a 2147483647,
                       pois se o n√∫mero estiver fora desse
                       intervalo ele teria mais de 4 bytes.
                 */

char caractere = 'A'; /* 1 byte -&gt; s√≥ aceita um caractere,
                           porque um caractere ocupa um
                           byte.
                      */

float real = 3.14; /* 4 bytes -&gt; s√≥ suporta valores entre 
                        10E-38 e 10E38 (isso significa 10
                        vezes 10 elevado a -38 a 38, o &quot;E&quot;
                        substitui o &quot;vezes 10 elevado a&quot;
                        para simplificar para o computador).
                   */

double real_2 = 10E49; /* 6 bytes -&gt; o double tem mais
                              espa√ßo que um float
                              e por isso pode suportar
                              n√∫meros entre 10E-4932 e
                              10E4932
                           */
</code></pre>
<blockquote>
<p>Essas quantidades demonstradas acima n√£o s√£o iguais em todas as arquiteturas (tipo de processador), isto quer dizer que se o seu computador √© de 32 bits o tamanho das vari√°veis pode ser diferente de um de 64 bits, logo, para que voc√™ tenha certeza do tamanho delas (em bytes) √© s√≥ usar o <code>sizeof</code>:</p>
</blockquote>
<pre><code class="language-c">int inteiro;
int tmh_inteiro = sizeof inteiro; // tamanho da vari√°vel inteiro
</code></pre>
<blockquote>
<p>Caso voc√™ n√£o queira criar uma vari√°vel unicamente para pegar o seu tamanho √© poss√≠vel usar o <code>sizeof</code> para pegar o tamanho do tipo diretamente:</p>
</blockquote>
<pre><code class="language-c">int tmh_inteiro = sizeof (int); // tamanho da vari√°vel inteiro
</code></pre>
<blockquote>
<p>Note que o tipo est√° entre par√™nteses, isso √© obrigat√≥rio ou o C vai achar que voc√™ est√° se referindo a uma vari√°vel.</p>
</blockquote>
<p>E a galera que j√° conhece um pouco de programa√ß√£o deve estar se perguntando <em>‚ÄúMas e os booleanos? No C n√£o existe verdadeiro e falso?‚Äù</em>  sim, mas no C o <code>int</code> faz esse papel, sendo que o <strong>0</strong> equivale a <strong>falso</strong> e o <strong>1</strong> equivale a <strong>verdadeiro</strong>.</p>
<p>As vari√°veis em C (e acho que em todas as linguagens) t√™m algumas regras quanto √† escolha do seu nome, estas regras s√£o:</p>
<ol>
<li>Vari√°veis n√£o podem iniciar com n√∫meros;</li>
<li>Vari√°veis n√£o podem ter espa√ßos (substitua os espa√ßos por <code>_</code>);</li>
<li>Vari√°veis s√≥ podem conter letras, n√∫meros e travess√µes (evite usar letras com acento tamb√©m);</li>
<li>Vari√°veis n√£o podem ser iguais √† palavras reservadas.</li>
</ol>
<blockquote>
<p>Palavras reservadas do C:</p>
</blockquote>
<pre><code class="language-c">auto break case char if const continue  default do double else enum
extern float for goto if int long register return short signed void
sizeof static struct  switch  typedef union unsigned volatile while
</code></pre>
<p>Sendo assim, vari√°veis com nomes como <code>2letras</code>, <code>char</code>, <code>jo%ao</code> ou <code>peso da pedra</code> est√£o erradas, mas vari√°veis como <code>_2letras</code>, <code>Char</code>, <code>joao</code> ou <code>peso_da_pedra</code> est√£o certas, e tome muito cuidado com o uso de mai√∫sculas e min√∫sculas, pois o C as diferencia, portanto, <code>char</code> √© uma palavra reservada, mas <code>Char</code> n√£o √©.</p>
<p>Uma forma de atribui√ß√£o do C que pode ser meio confuso pode ser dado pelo seguinte c√≥digo:</p>
<pre><code class="language-c">int c = 80;
int i = (c = 30); // i vai valer 30
c = c + (i = 20); // c vai valer 50
</code></pre>
<blockquote>
<p>Isso ocorre, porque o C atribui o <code>30</code> a vari√°vel <code>c</code> e retorna o valor para <code>i</code>.</p>
</blockquote>
<h3 id="conflito-entre-tipos"><a class="header" href="#conflito-entre-tipos">Conflito entre tipos</a></h3>
<p>Um problema (na minha opini√£o) do C √© a forte tipagem, que significa que os tipos t√™m que ser respeitados a todo o custo, logo, se queremos que um dado seja transformado em outro, precisamos fazer convers√µes de tipos.</p>
<pre><code class="language-c">int Um = (int) 1.5; // apenas o 1 ser√° atribu√≠do
</code></pre>
<p>Quando voc√™ atribui a uma vari√°vel um valor que pertence a outro tipo, o C vai converter isso para o tipo da vari√°vel:</p>
<pre><code class="language-c">int i = 1.5; // i vai valer 1
float f =  i / 3; /*
                     o resultado dessa divis√£o seria 0.3333...
                     Mas como os dois  n√∫meros s√£o inteiros o
                     resultado  √©  0, e por  isso √©  atribu√≠do
                     o valor 0.0 √† vari√°vel f
                  */
</code></pre>
<blockquote>
<p>Portanto, sempre use vari√°veis do mesmo tipo para opera√ß√µes matem√°ticas, caso sejam de tipos diferentes use a convers√£o de tipos.</p>
</blockquote>
<p>Para que o resultado seja atribu√≠do da forma correta, voc√™ deve fazer a convers√£o de tipos ou usar o tipo certo no calculo:</p>
<pre><code class="language-c">float f = 1.0 / 2.0;        // usando o tipo certo (float)
f = (float) 1 / (float) 2;  /* usando a convers√£o de tipos 
                                            tamb√©m conhecida como
                                            &quot;type cast&quot;
                            */

int  n = 5, n1 = 2;

f = n / n1;                 // f = 2.0
f = (float) n / (float) n1; // f = 2.5
</code></pre>
<blockquote>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conceitos-interessantes"><a class="header" href="#conceitos-interessantes">Conceitos interessantes</a></h1>
<h2 id="modificadores-de-tipo"><a class="header" href="#modificadores-de-tipo">Modificadores de tipo</a></h2>
<p>E mais uma vez falaremos de tipos primitivos, como hav√≠amos visto, os tipos primitivos t√™m tamanhos diferentes na mem√≥ria, e estes tamanhos podem ser expandidos ou reduzidos.</p>
<h3 id="long"><a class="header" href="#long">Long</a></h3>
<p>O <code>long</code> alonga (expande) a capacidade de vari√°veis do tipo <code>int</code>, <code>float</code> e <code>double</code>.</p>
<blockquote>
<p>Lembrando que os valores de tamanho variam de computador para computador.</p>
</blockquote>
<pre><code class="language-c">int inteiro = 0;              // 4 bytes
long int l_inteiro = 0;       // 8 bytes

double real = 10E49;          // 6 bytes
long double l_real = 10e49;   // 8 bytes
</code></pre>
<p>E para alcan√ßar o m√°ximo de tamanho de uma vari√°vel para a sua arquitetura use o <code>long long int</code> ou simplesmente <code>long long</code>.</p>
<h3 id="short"><a class="header" href="#short">Short</a></h3>
<p>O <code>short</code> encurta a capacidade de vari√°veis do tipo <code>int</code>.</p>
<pre><code class="language-c">int inteiro = 0;              // 4 bytes
short int s_inteiro = 0;      // 2 bytes
</code></pre>
<h3 id="signed-e-unsigned"><a class="header" href="#signed-e-unsigned">Signed e unsigned</a></h3>
<p><code>signed</code> e <code>unsigned</code> significam respectivamente ‚Äúcom sinal‚Äù e ‚Äúsem sinal‚Äù.</p>
<pre><code class="language-c">int c = 90;
int i = +90;
int j = -90;
</code></pre>
<p>Sempre que voc√™ declara um n√∫mero, ele por padr√£o √© <code>signed</code>, portanto suporta n√∫meros negativos e positivos, e o <code>unsigned</code> s√≥ suporta n√∫meros positivos.</p>
<pre><code class="language-c">int inteiro = 0;               // intervalo: -2147483648 a 2147483647
unsigned int us_inteiro = 0;    // intervalo: 0           a 4294967295
</code></pre>
<h2 id="entrada-e-sa√≠da-de-dados"><a class="header" href="#entrada-e-sa√≠da-de-dados">Entrada e sa√≠da de dados</a></h2>
<p>Voc√™ j√° viu anteriormente uma forma de sa√≠da de dados: o <code>printf</code>:</p>
<pre><code class="language-c">printf(&quot;Hello mundo!!\n&quot;);
</code></pre>
<blockquote>
<p>Sem este <code>\n</code>, caso voc√™ escreva outra coisa os dois ir√£o aparecer juntos.</p>
</blockquote>
<h3 id="caractere-de-scape---"><a class="header" href="#caractere-de-scape---">Caractere de scape ( ‚Äú\‚Äù )</a></h3>
<p>O caractere de scape, no C, √© o <code>\</code> e ele d√° ‚Äúpoderes‚Äù ao seu texto, pode ser usado em vari√°veis do tipo <code>char</code> e em strings, mas para ilustr√°-lo eu irei represent√°-lo sempre dentro de um <code>printf</code>.</p>
<h4 id="n"><a class="header" href="#n">\n</a></h4>
<pre><code class="language-c">printf(&quot;\n1¬™ linha\n2¬™ linha\n3¬™ linha\n&quot;);   // \n: quebra de linha.
</code></pre>
<p>Esse <code>\n</code> √© uma quebra de linha, ou seja, sempre que tiver um <code>\n</code> o <code>printf</code> vai pular uma linha e escrever o que estiver na frente.</p>
<blockquote>
<p>sa√≠da:</p>
</blockquote>
<pre><code>1¬™ linha
2¬™ linha
3¬™ linha
</code></pre>
<h4 id="t"><a class="header" href="#t">\t</a></h4>
<pre><code class="language-c">printf(&quot;\tjoao&quot;); // \t: espa√ßamento ou tabula√ß√£o (efeito da tecla &quot;tab&quot;).
</code></pre>
<p>Esse <code>\t</code> √© uma tabula√ß√£o, o que estiver a frente dele ir√° se deslocar para a direita (-&gt;).</p>
<blockquote>
<p>sa√≠da:</p>
</blockquote>
<pre><code>   joao
</code></pre>
<h4 id="b"><a class="header" href="#b">\b</a></h4>
<pre><code class="language-c">printf(&quot;joao\b&quot;);  // \b: apaga um caractere da linha (efeito da tecla &quot;backspace&quot;).
</code></pre>
<p>Esse <code>\b</code> √© um backspace, o caractere anterior a ele ser√° apagado.</p>
<blockquote>
<p>sa√≠da:</p>
</blockquote>
<pre><code>joa
</code></pre>
<h4 id="r"><a class="header" href="#r">\r</a></h4>
<pre><code class="language-c">printf(&quot;coisas mais coisas\r outras coisas&quot;); // \r: elimina tudo o que est√° antes dele na linha.
</code></pre>
<p>Esse <code>\r</code> vem de ‚Äúremove‚Äù, todos os caracteres da mesma linha e anteriores a ele ser√£o apagados.</p>
<blockquote>
<p>sa√≠da:</p>
</blockquote>
<pre><code> outras coisas
</code></pre>
<h4 id="v"><a class="header" href="#v">\v</a></h4>
<pre><code class="language-c">printf(&quot;coisas\voutrascoisas\vjoao\v.&quot;); // \v: tabula√ß√£o vertical.
</code></pre>
<p>O <code>\v</code> vai quebrar a linha assim como o <code>\n</code>, mas em vez de iniciar a nova no inicio da linha, ele inicia no ‚Äúfinal‚Äù da anterior, formando uma ‚Äúescadinha‚Äù.</p>
<blockquote>
<p>sa√≠da:</p>
</blockquote>
<pre><code>coisas
      outrascoisas
                  joao
                      .
</code></pre>
<h4 id=""><a class="header" href="#">\‚Äù</a></h4>
<pre><code class="language-c">printf(&quot;\&quot;joao\&quot; √© um nome feio&quot;); // \&quot;: exibe as aspas duplas.
</code></pre>
<p>Exibe as aspas duplas ( <code>&quot;</code> ), pois se voc√™ escrever simplesmente <code>&quot;</code> o C vai achar que aquele √© o fim da string.</p>
<blockquote>
<p>sa√≠da:</p>
</blockquote>
<pre><code class="language-c">&quot;joao&quot; √© um nome feio
</code></pre>
<h4 id="-1"><a class="header" href="#-1">\‚Äò</a></h4>
<pre><code class="language-c">printf(&quot;it\'s estranho&quot;); // \': exibe as aspas simples ou ap√≥trofos.
</code></pre>
<p>Exibe a aspa simples (que alguns chamam de ap√≥strofo).</p>
<blockquote>
<p>sa√≠da:</p>
</blockquote>
<pre><code>it's estranho
</code></pre>
<h4 id="-2"><a class="header" href="#-2">\\</a></h4>
<pre><code class="language-c">printf(&quot;isso √© uma contra-barra: \\&quot;);     // \\: exibe a contra-barra
</code></pre>
<blockquote>
<p>sa√≠da:</p>
</blockquote>
<pre><code>isso √© uma contra-barra: \
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entrada-e-sa√≠da-de-dados-1"><a class="header" href="#entrada-e-sa√≠da-de-dados-1">Entrada e sa√≠da de dados</a></h1>
<h3 id="printf"><a class="header" href="#printf">printf</a></h3>
<p><em>‚ÄúMas e se eu quiser imprimir uma vari√°vel?‚Äù</em> ... √© s√≥ usar a formata√ß√£o de texto do <code>printf</code> ... <em>‚ÄúMas como se usa isso?‚Äù</em> ... para imprimir uma vari√°vel <code>int</code> √© s√≥ escrever um <code>%i</code> ou <code>%d</code> dentro da string. Se for um <code>char</code>, escreva <code>%c</code> na string, se for <code>float</code>, escreva <code>%f</code>, se for uma nota√ß√£o cient√≠fica (geralmente usada no tipo <code>double</code>), escreva <code>%E</code>( se estiver usando o ‚Äúe‚Äù mai√∫sculo) e <code>%e</code> para o ‚Äúe‚Äù min√∫sculo, ap√≥s escrever a formata√ß√£o desejada, √© s√≥ listar as vari√°veis separando por v√≠rgula ligo ap√≥s a string... <em>‚ÄúEu n√£o entendi nada do que tu disse!‚Äù</em> ...Relaxa... Olhe o exemplo e suas d√∫vidas em rela√ß√£o a isso ir√£o desaparecer:</p>
<pre><code class="language-c">int numero = 90;
char caractere = 'A';
float real = 9.23;
double real_em_dobro_E = 9.4E13;
double real_em_dobro_e = 9.4e13;

printf(&quot;numero inteiro: %i&quot;, numero);
printf(&quot;numero real: %f&quot;, real);
printf(&quot;numero real nota√ß√£o cientifica com \&quot;E\&quot;: %E&quot;, real_em_dobro_E);
printf(&quot;numero real nota√ß√£o cientifica com \&quot;e\&quot;: %e&quot;, real_em_dobro_e);
printf(&quot;caractere: %c&quot;, caractere);
</code></pre>
<blockquote>
<p>sa√≠da:</p>
</blockquote>
<pre><code>numero inteiro: 90
numero real: 9.23
numero real nota√ß√£o cientifica com &quot;E&quot;: 9.4E13
numero real nota√ß√£o cientifica com &quot;e&quot;: 9.4e13
caractere: A
</code></pre>
<h3 id="scanf"><a class="header" href="#scanf">scanf</a></h3>
<p>O scanf √© semelhante ao printf, mas serve para ler dados:</p>
<pre><code class="language-c">int numero;

scanf(&quot;%i&quot;, &amp;numero);
</code></pre>
<p>T√°, eu sei que voc√™ est√° se perguntando <em>‚Äúe esse</em> <code>&amp;</code> <em>serve pra que?‚Äù</em> Esse <code>&amp;</code> diz para o <code>scanf</code> colocar o valor no lugar da mem√≥ria onde est√° o n√∫mero. O <code>&amp;</code> simboliza um endere√ßamento de mem√≥ria, o <code>scanf</code> coloca o valor direto no local da mem√≥ria onde est√° a vari√°vel.</p>
<p>E como voc√™ pode perceber o <code>%i</code> se refere a um n√∫mero inteiro. Todos os tipos de vari√°veis s√£o simbolizados pelos s√≠mbolos (<code>%i</code>, <code>%c</code>, <code>%f</code>...) do <code>printf</code>.</p>
<p>Tamb√©m √© poss√≠vel ler v√°rias vari√°veis com um √∫nico comando:</p>
<pre><code class="language-c">int numero;
char caractere;
float real;

printf(&quot;digite um numero um caractere e um numero real: \n&quot;);
scanf(&quot;%i %c %f&quot;, &amp;numero, &amp;caractere, &amp;real);

printf(&quot;\nnumero inteiro: %i&quot;, numero);
printf(&quot;numero real: %f&quot;, real);
printf(&quot;caractere: %c&quot;, caractere);
</code></pre>
<blockquote>
<p>Na hora de ler um <code>char</code>, √†s vezes o <code>scanf</code> buga, isso ocorre quando ele recebe lixo do teclado, voc√™ s√≥ precisa ler a vari√°vel duas vezes, isso geralmente ocorre com <code>char</code>, mas se acontecer com outro tipo, a resolu√ß√£o para o problema √© a mesma:</p>
</blockquote>
<pre><code class="language-c">fflush(stdin); // esse comando vai limpar o lixo da mem√≥ria
</code></pre>
<blockquote>
<p>Sa√≠da:</p>
</blockquote>
<pre><code>digite um numero, um caractere e um numero real:
3458
J
5.8769
&gt;
numero inteiro: 3458
numero real: 5.8769
caractere: J
</code></pre>
<p>Esses n√£o s√£o os √∫nicos m√©todos de entrada e sa√≠da de dados, mas veremos outros em outros cap√≠tulos, esses s√£o o bastante para prosseguirmos nossos estudos.</p>
<h3 id="formatos-do-printf-e-scanf"><a class="header" href="#formatos-do-printf-e-scanf">Formatos do printf e scanf</a></h3>
<h4 id="s"><a class="header" href="#s">%s</a></h4>
<p>Strings ou texto, exemplo:</p>
<pre><code class="language-c">printf(&quot;string: '%s'\n&quot;, &quot;string&quot;);
</code></pre>
<h4 id="d-e-i"><a class="header" href="#d-e-i">%d e %i</a></h4>
<p>Inteiros, exemplo:</p>
<pre><code class="language-c">printf(&quot;int: %i\n&quot;, 90);
</code></pre>
<h4 id="f"><a class="header" href="#f">%f</a></h4>
<p>Reais, exemplo:</p>
<pre><code class="language-c">printf(&quot;float: %f\n&quot;, 9.3);
</code></pre>
<p>E como s√£o n√∫meros com <code>.</code> voc√™ pode formatar a sa√≠da deles, o <code>9.3</code> vai ser exibido como <code>9.300000</code>, mas eu quero que saia <code>9.3</code></p>
<pre><code class="language-c">printf(&quot;float: %.1f\n&quot;, 9.3);
</code></pre>
<blockquote>
<p>Notem que entre o <code>%</code> e o <code>f</code> existe um <code>.1</code>, isso quer dizer que s√≥ √© para exibir <code>1</code> numero ap√≥s a ‚Äúv√≠rgula‚Äù(que no C √© um <code>.</code>).</p>
</blockquote>
<p>O prot√≥tipo √© mais ou menos assim:</p>
<pre><code class="language-c">printf(&quot;%.&lt;decimais&gt;f\n&quot;, &lt;numero&gt;);
</code></pre>
<h4 id="c"><a class="header" href="#c">%c</a></h4>
<p>Caracteres, exemplo:</p>
<pre><code class="language-c">printf(&quot;char: %c\n&quot;, 'A');
</code></pre>
<h4 id="o"><a class="header" href="#o">%o</a></h4>
<p>Numeros octais, exemplo:</p>
<pre><code class="language-c">printf(&quot;int: %o\n&quot;, 018);
</code></pre>
<blockquote>
<p>Numeros octais iniciam com <code>0</code>, logo <code>012</code> √© o mesmo que <code>10</code></p>
</blockquote>
<h4 id="u"><a class="header" href="#u">%u</a></h4>
<p>Numeros sem sinal, exemplo:</p>
<pre><code class="language-c">printf(&quot;int: %u\n&quot;, 18);
</code></pre>
<h4 id="x"><a class="header" href="#x">%x</a></h4>
<p>Numeros hexadecimais, exemplo:</p>
<pre><code class="language-c">printf(&quot;int: %x\n&quot;, 0xDB7B5);
</code></pre>
<blockquote>
<p>Todo hexadecimal come√ßa com <code>0x</code>.</p>
</blockquote>
<h4 id="l"><a class="header" href="#l">%l</a></h4>
<p>Numeros longos (sempre acompanhado pelo tipo alongado), exemplo:</p>
<pre><code class="language-c">// Reais longos
printf(&quot;double: %lf\n&quot;, (double) 9.3);

// Inteiros longos
printf(&quot;long int: %li\n&quot;, 698);
</code></pre>
<h3 id="putchar-e-puts"><a class="header" href="#putchar-e-puts">Putchar e puts</a></h3>
<p>Basicamente o ‚Äúput‚Äù significa coloque, logo, <code>putchar</code> √© coloque um <code>char</code>:</p>
<pre><code class="language-c">char c = '\n';

putchar ('j');
putchar ('o');
putchar ('√£');
putchar ('o');
putchar ( c );
putchar ('!');
putchar ( c );
</code></pre>
<blockquote>
<p>Sa√≠da:</p>
</blockquote>
<pre><code>joao
!
</code></pre>
<p>E seguindo a mesma l√≥gica, <code>puts</code> √© coloque uma string ( o <code>s</code> √© uma abrevia√ß√£o ).</p>
<pre><code class="language-c">char * str = &quot;string coisada&quot;;

puts ( &quot;joao&quot; );
puts ( &quot;!&quot; );

puts ( str );
</code></pre>
<blockquote>
<p>Sa√≠da:</p>
</blockquote>
<pre><code>joao
!
string coisada
</code></pre>
<blockquote>
<p>Uma particularidade do <code>puts</code> √© que ele adiciona um <code>\n</code> no fim da string.</p>
</blockquote>
<h3 id="getchar-e-gets"><a class="header" href="#getchar-e-gets">Getchar e gets</a></h3>
<p>Assim como o <code>scanf</code>, o <code>getchar</code> e o <code>gets</code>, s√£o fun√ß√µes para leitura de dados, mas que s√≥ servem para ler vari√°veis do tipo <code>char</code> e strings.</p>
<p>√â assim que se usa o <code>getchar</code>:</p>
<pre><code class="language-c">char j;

j = getchar();
</code></pre>
<p>E o <code>gets</code> √© usado assim:</p>
<pre><code class="language-c">char str [20];
gets(str);
</code></pre>
<blockquote>
<p>Mesmo o <code>gets</code> sendo uma fun√ß√£o contraindicada pela comunidade, ela ainda funciona, ent√£o caso o gcc aponte erros pelo uso do <code>gets</code>, saiba que ela vai funcionar normalmente.</p>
</blockquote>
<h3 id="fprintf-e-fgets"><a class="header" href="#fprintf-e-fgets">Fprintf e fgets</a></h3>
<p>O <code>f</code> antes do <code>printf</code> significa formata√ß√£o, logo, um <code>fprintf</code> √© um <code>printf</code> formatado, e essa formata√ß√£o √© basicamente um par√¢metro a mais indicando o lugar onde voc√™ quer escrever a informa√ß√£o.</p>
<pre><code class="language-c">fprintf(stdout, &quot;Hello mundo!!\n&quot;); // printf ( &quot;Hello mundo!!&quot; )
</code></pre>
<blockquote>
<p>O <code>stdout</code> √© um ‚Äústream‚Äù ( local para onde vai a string do <code>fprintf</code> ), e o <code>printf</code> √© um <code>fprintf</code> com o <code>stdout</code> como ‚Äústream‚Äù, e o <code>stdout</code> √© a sa√≠da padr√£o (a tela).</p>
</blockquote>
<p>Mas tamb√©m √© poss√≠vel enviar a sa√≠da para outros streams, dentre eles n√≥s temos o <code>stderr</code>, que √© a sa√≠da padr√£o de erros:</p>
<pre><code class="language-c">char coisa [30];

puts(&quot;escreva de 1 a 10 caracteres: &quot;);
scanf (&quot;%s&quot;, &amp;coisa );

if (coisa [0] == '\0' ) {
   fprintf ( stderr, &quot;ERROR: voc√™ n√£o digitou nenhum caractere!&quot;);
   return 1;
}

if (coisa [10] != '\0' ) {
   fprintf ( stderr, &quot;ERROR: voc√™ digitou caracteres demais!&quot;);
   return 1;
}
</code></pre>
<blockquote>
<p>No programa acima s√£o pedidos caracteres de 1 a 10, ent√£o se o caractere da posi√ß√£o <code>0</code> corresponder ao fim de uma string (<code>'\0'</code>) quer dizer que 0 caracteres foram lidos, e se o 11¬∫ caractere (posi√ß√£o <code>10</code>) for o fim da string (<code>'\0'</code>) quer dizer que existem mais de 10 caracteres na string.</p>
</blockquote>
<p>Note que quando ocorreu um erro o valor retornado foi o <code>1</code>, indicando para o sistema operacional que aconteceu um erro.</p>
<p>O <code>fgets</code> seria um <code>gets</code> formatado, e ele funciona da seguinte maneira:</p>
<pre><code class="language-c">char str[10];

fgets ( stdin, 10, str ); // gets (str)
</code></pre>
<blockquote>
<p>O <code>stdin</code> √© a entrada de dados padr√£o (o teclado).</p>
</blockquote>
<p><em>‚ÄúU√©? Ent√£o por que eu deveria usar esse <code>fgets</code> a√≠ se o <code>gets</code> √© mais simples?‚Äù</em> ...Muito simples, lembra que o <code>gets</code> tem um problema, tanto que ele √© contra-indicado pelo pr√≥prio compilador? Pois √©, o <code>fgets</code> n√£o tem esse problema, porque nele al√©m de voc√™ indicar a string a ser lida e o ‚Äústream‚Äù, ele exige que voc√™ coloque o tamanho da string, assim evitando colocar dados no lugar errado.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operadores"><a class="header" href="#operadores">Operadores</a></h1>
<h3 id="aritm√©ticos"><a class="header" href="#aritm√©ticos">Aritm√©ticos</a></h3>
<p>Os operadores aritm√©ticos s√£o os operadores matem√°ticos e s√£o expressos da seguinte maneira em C:</p>
<pre><code class="language-c">n + N // Adi√ß√£o            -&gt; soma os dois n√∫meros;
n - N // Subtra√ß√£o         -&gt; subtrai os dois n√∫meros;
n * N // Multiplica√ß√£o     -&gt; multiplica dois n√∫meros;
n / N // Divis√£o           -&gt; divide dois n√∫meros;
n % N // resto da divis√£o  -&gt; retorna o resto da diviv√£o entre dois n√∫meros.
</code></pre>
<blockquote>
<p>para evitar erros sempre fa√ßa opera√ß√µes com n√∫meros de tipos iguais.</p>
</blockquote>
<p>E nunca se esque√ßa que em express√µes num√©ricas existe uma ordem de preced√™ncia, logo, <code>6+4/2</code> √© <code>8</code> e n√£o <code>5</code>, e isso acontece porque assim como na matem√°tica √© resolvida primeiro a divis√£o (<code>4/2</code>) e depois √© somado <code>6</code> a esse valor.</p>
<p>Ordem de preced√™ncia:</p>
<ul>
<li>par√™nteses (<code>( )</code>)</li>
<li>multiplica√ß√£o (<code>*</code>), diviv√£o (<code>/</code>) e resto (<code>%</code>)</li>
<li>adi√ß√£o (<code>+</code>) e subtra√ß√£o (<code>-</code>)</li>
</ul>
<pre><code class="language-c">6+4/2    //  -&gt;  8
(6+4)/2  //  -&gt;  5
</code></pre>
<h3 id="atribui√ß√£o"><a class="header" href="#atribui√ß√£o">Atribui√ß√£o</a></h3>
<p>O operadores de atribui√ß√£o s√£o formas simplificadas de atribuir valores... <em>‚ÄúN√£o entendi...‚Äù</em></p>
<p>Isso √© uma atribui√ß√£o:</p>
<pre><code class="language-c">numero = 89;
</code></pre>
<p>E caso eu queira que este n√∫mero valia ele mesmo + 1 eu fa√ßo:</p>
<pre><code class="language-c">numero = numero + 1;
</code></pre>
<p>Mas para poupar esfor√ßos o C tamb√©m aceita:</p>
<pre><code class="language-c">numero += 1;
</code></pre>
<p>E isso vale para qualquer opera√ß√£o:</p>
<pre><code class="language-c">numero += 2; // numero = numero + 2
numero -= 3; // numero = numero - 3
numero *= 7; // numero = numero * 7
numero /= 2; // numero = numero / 2
</code></pre>
<p>Al√©m desses tamb√©m existe os operadores de incremento e decremento:</p>
<pre><code class="language-c">numero ++; // numero = numero + 1
numero --; // numero = numero - 1
</code></pre>
<blockquote>
<p>os vistos acima s√£o denominados de p√≥s incremento, pois a vari√°vel s√≥ recebe o valor depois de retorna-lo <em>‚ÄúO que?‚Äù</em> ... Observe:</p>
</blockquote>
<pre><code class="language-c">int numero = 89;
printf(&quot;%i\n&quot;, numero++ );
</code></pre>
<blockquote>
<p>Sa√≠da:</p>
</blockquote>
<pre><code>89
</code></pre>
<p><em>‚ÄúPera! mas ele n√£o deveria ser 90?‚Äù</em> ... A vari√°vel <code>numero</code> s√≥ √© incrementada depois de retornar o valor dela, isso quer dizer que ela s√≥ √© incrementada depois dessa parte do programa, mas se voc√™ usar o pr√©-incremento:</p>
<pre><code class="language-c">int numero = 89;
printf(&quot;%i\n&quot;, ++numero );
</code></pre>
<blockquote>
<p>Sa√≠da:</p>
</blockquote>
<pre><code>90
</code></pre>
<pre><code class="language-c">numero ++; // p√≥s-incremento
numero --; // p√≥s-decremento

++ numero; // pr√©-incremento
-- numero; // pr√©-decremento
</code></pre>
<h3 id="relacionais"><a class="header" href="#relacionais">Relacionais</a></h3>
<p>Os operadores l√≥gicos s√£o todos aqueles que testam uma express√£o relacional e dizem se ela √© verdadeira ou falsa.</p>
<blockquote>
<p>lembrando que no C verdadeiro √© 1 e falso √© 0.</p>
</blockquote>
<pre><code class="language-c">n == N // igual            -&gt; testa se n √© igual a N;
n != N // diferente        -&gt; testa se n √© diferente de N;

n &lt;  N // menor que        -&gt; testa se n √© menor que N;
n &gt;  N // maior que        -&gt; testa se n √© maior que N;

n &lt;= N // menor ou igual   -&gt; testa se n √© menor ou igual a N;
n &gt;= N // maior ou igual   -&gt; testa se n √© maior ou igual a N;
</code></pre>
<p>Exemplo simples:</p>
<pre><code class="language-c">printf(&quot;%i\n&quot;, 1 &lt; 2);
printf(&quot;%i\n&quot;, 1 &gt; 2);
printf(&quot;%i\n&quot;, 1 != 2);
printf(&quot;%i\n&quot;, 1 == 2);
</code></pre>
<blockquote>
<p>Sa√≠da:</p>
</blockquote>
<pre><code>1
0
1
0
</code></pre>
<blockquote>
<p>E lembrem-se que os tipos dos dados sendo testados tem que ser o mesmo.</p>
</blockquote>
<p>Eles ser√£o usados por voc√™s nas estruturas condicionais, la√ßos de repeti√ß√£o e com o <strong>operador tern√°rio</strong>.</p>
<h3 id="l√≥gicos"><a class="header" href="#l√≥gicos">L√≥gicos</a></h3>
<p>Os operadores l√≥gicos s√£o usados para assimilar opera√ß√µes que retornam valores l√≥gicos... <em>‚ÄúComo assim?‚Äù</em> ... S√£o usados para opera√ß√µes verdadeiras e falsas.</p>
<blockquote>
<p>Jo√£o pede ao seu pai um fone de ouvido e um celular, mas o seu pai s√≥ d√° o fone de ouvido, e ele fica insatisfeito pois ele queria as duas coisas.</p>
</blockquote>
<p>Jo√£o s√≥ ficaria satisfeito ( verdadeiro ) se ele ganhasse o celular e o fone de ouvido, como ele s√≥ ganhou o fone ele ficou insatisfeito ( falso ).</p>
<p>O operador usado no exemplo acima √© o ‚Äúand‚Äù ( <code>&amp;&amp;</code> ) que s√≥ √© ‚Äúverdadeiro‚Äù se as duas op√ß√µes forem verdadeiras, exemplo:</p>
<pre><code class="language-c">printf(&quot;%i &amp;&amp; %i = %i\n&quot;, 1 &lt; 5, 2 &gt; 0, 1 &lt; 5   &amp;&amp;   2 &gt; 0);
printf(&quot;%i &amp;&amp; %i = %i\n&quot;, 1+80 &lt; 5, 2 &gt; 0, 1+80 &lt; 5   &amp;&amp;   2 &gt; 0);
</code></pre>
<blockquote>
<p>Sa√≠da:</p>
</blockquote>
<pre><code>1 &amp;&amp; 1 = 1
0 &amp;&amp; 1 = 0
</code></pre>
<p>Os operadores l√≥gicos s√£o o <code>&amp;&amp;</code>, que equivale a ‚Äúand‚Äù(‚Äùe‚Äù), j√° visto anteriormente, o <code>||</code>, que equivale a ‚Äúor‚Äù(‚Äùou‚Äù) e o <code>!</code>, que equivale a ‚Äúnot‚Äù(‚Äùn√£o‚Äù).</p>
<blockquote>
<p>considere os uns e zeros abaixo apenas o resultado de alguma opera√ß√£o relacional...</p>
</blockquote>
<table><thead><tr><th></th><th><code>&amp;&amp;</code></th><th></th><th>resultado final</th></tr></thead><tbody>
<tr><td><code>1</code></td><td><code>&amp;&amp;</code></td><td><code>1</code></td><td>1</td></tr>
<tr><td><code>0</code></td><td><code>&amp;&amp;</code></td><td><code>1</code></td><td>0</td></tr>
<tr><td><code>1</code></td><td><code>&amp;&amp;</code></td><td><code>0</code></td><td>0</td></tr>
<tr><td><code>0</code></td><td><code>&amp;&amp;</code></td><td><code>0</code></td><td>0</td></tr>
</tbody></table>
<p>|             |<code>||</code>|             | resultado final |
|-------------|----|-------------|-----------------|
| <code>1</code>         |<code>||</code>| <code>1</code>         | 1               |
| <code>0</code>         |<code>||</code>| <code>1</code>         | 1               |
| <code>1</code>         |<code>||</code>| <code>0</code>         | 1               |
| <code>0</code>         |<code>||</code>| <code>0</code>         | 0               |</p>
<table><thead><tr><th><code>!</code></th><th></th><th>resultado final</th></tr></thead><tbody>
<tr><td><code>!</code></td><td><code>1</code></td><td>0</td></tr>
<tr><td><code>!</code></td><td><code>0</code></td><td>1</td></tr>
</tbody></table>
<p>Exemplo:</p>
<pre><code class="language-c">printf(&quot;%i &amp;&amp; %i = %i\n&quot;, 1 &lt; 5, 2 &gt; 0, 1 &lt; 5   &amp;&amp;   2 &gt; 0);

printf(&quot;%i || %i = %i\n&quot;, 1 &lt; 5, 2 &gt; 6, 1 &lt; 5   ||   2 &gt; 6);

printf(&quot;!(%i &amp;&amp; %i) = %i\n&quot;, 1 &lt; 5, 2 &gt; 6, !(1 &lt; 5   &amp;&amp;   2 &gt; 6));
</code></pre>
<blockquote>
<p>Sa√≠da:</p>
</blockquote>
<pre><code>1 &amp;&amp; 1 = 1
1 || 0 = 1
!(1 &amp;&amp; 0) = 1
</code></pre>
<h3 id="tern√°rio-ou-condicional"><a class="header" href="#tern√°rio-ou-condicional">Tern√°rio ou condicional</a></h3>
<pre><code class="language-c">int  numero = 80;
char imparOuPar = (  numero % 2 == 0  ) ? 'p'               : 'i'              ;
//                ( &lt;express√£o logica&gt; ) ? &lt;se for Verdade&gt;  : &lt;se for Mentira&gt;
</code></pre>
<p>O c√≥digo acima representa um uso simples do operador tern√°rio e eu sei que voc√™ deve estar um pouco confuso com isso, mas eu explico:</p>
<blockquote>
<p>Antes de mais nada, saiba que <strong>todo n√∫mero par tem o resto da divis√£o por 2 igual 0</strong> , ent√£o, no exemplo acima, caso <code>( numero % 2 == 0 )</code> seja verdadeiro, o operador vai retornar <code>'p'</code> de par, caso a express√£o seja falso, ele vai retornar <code>'i'</code> de √≠mpar, portanto, o C vai testar a express√£o l√≥gica entre <code>(</code> e <code>)</code> se essa express√£o for verdadeira, o valor da opera√ß√£o vai ser o que est√° entre <code>?</code>, e caso contr√°rio, o valor ser√° o que est√° ap√≥s <code>:</code></p>
</blockquote>
<p>Outro exemplo do uso seria:</p>
<pre><code class="language-c">int nota = 6;
char status = ( nota &gt;= 7 ) ? 'p' : 'r';

printf(&quot;Jo√£o %s de ano&quot;, (status=='p')? &quot;passou&quot; : &quot;reprovou&quot; );
</code></pre>
<p>No c√≥digo acima, se a nota do Jo√£o for maior ou igual a 7, o programa escreve <code>&quot;Jo√£o passou de ano&quot;</code> na tela, se n√£o, ele escreve <code>&quot;Jo√£o reprovou de ano&quot;</code>.</p>
<h2 id="chegou-a-hora-de-praticar"><a class="header" href="#chegou-a-hora-de-praticar">Chegou a hora de praticar!</a></h2>
<p>Agora chegou a hora de praticar, e n√£o pule essa parte, pois o seu aprendizado s√≥ √© absoluto se voc√™ praticar, ent√£o, para potencializar o seu aprendizado em C e em qualquer linguagem de programa√ß√£o:</p>
<blockquote>
<p>Dicas:</p>
<ol>
<li>Se tiver dificuldade em algo na hora da resolu√ß√£o do exerc√≠cio, primeiro volte ao assunto antes de consultar a resposta;</li>
<li>Sempre escreva todo o c√≥digo: n√£o use o <code>ctrl+C</code> e <code>ctrl+V</code> enquanto ainda est√° aprendendo, pois quando voc√™ escreve,  est√° acostumando o seu c√©rebro com a sintaxe da linguagem;</li>
<li>Sempre que voc√™ conseguir resolver o desafio, antes de pular para o pr√≥ximo, tente resolv√™-lo de novo de outra maneira;</li>
<li>Caso n√£o consiga resolver, veja a resposta e depois tente fazer de novo de outra maneira;</li>
<li>Crie seus pr√≥prios desafios para dificultar os que est√£o aqui.</li>
</ol>
</blockquote>
<p>Todos os desafios ser√£o resolvidos e explicados linha a linha, exceto o √∫ltimo de cada rodada, pois esse voc√™ vai ter que resolver sozinho, obrigatoriamente, para tentar provar para si mesmo que aprendeu e se voc√™ n√£o conseguir, leia de novo os conte√∫dos anteriores e tente novamente. Caso voc√™ passe para a pr√≥xima parte sem resolv√™-lo,  ter√° dificuldades posteriores em outros assuntos.</p>
<h3 id="desafio-1"><a class="header" href="#desafio-1">Desafio 1</a></h3>
<p>Fa√ßa uma calculadora onde o usu√°rio digite dois n√∫meros (reais) e no final ele exiba todas as opera√ß√µes matem√°ticas com esses n√∫meros:</p>
<blockquote>
<p>sa√≠da:</p>
</blockquote>
<pre><code>digite um n√∫mero: 3
digite outro n√∫mero: 4

3 + 4 = 5
3 - 4 = 5
3 * 4 = 12
3 / 4 = 0.75

A divis√£o inteira entre 3 e 4 √© 0 e o resto dessa divis√£o √© 3
</code></pre>
<h4 id="resposta"><a class="header" href="#resposta">Resposta</a></h4>
<p>Antes de mais nada, n√≥s temos que digitar nossa estrutura padr√£o:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int main (){

return 0;
}
</code></pre>
<p>Depois, n√≥s temos que pedir dois n√∫meros para o usu√°rio:</p>
<pre><code class="language-c">printf(&quot;digite um n√∫mero: &quot;);
printf(&quot;digite outro n√∫mero: &quot;);
</code></pre>
<p>Agora, iremos ler os dois n√∫meros, mas antes, temos que criar as vari√°veis que v√£o guardar esses n√∫meros:</p>
<pre><code class="language-c">float numero, outro_numero; // dessa forma criamos v√°rias vari√°veis do mesmo tipo de uma vez
</code></pre>
<p>Agora, n√≥s podemos ler os n√∫meros:</p>
<pre><code class="language-c">printf(&quot;digite um n√∫mero: &quot;);
scanf(&quot;%f&quot;, &amp;numero);

printf(&quot;digite outro n√∫mero: &quot;);
scanf(&quot;%f&quot;, &amp;numero);
</code></pre>
<p>Finalmente, iremos exibir os resultados:</p>
<pre><code class="language-c">printf(&quot;\n&quot;);
printf(&quot;%f + %f = %f\n&quot;, numero, outro_numero, numero + outro_numero);
printf(&quot;%f - %f = %f\n&quot;, numero, outro_numero, numero - outro_numero);
printf(&quot;%f * %f = %f\n&quot;, numero, outro_numero, numero * outro_numero);
printf(&quot;%f / %f = %f\n&quot;, numero, outro_numero, (float) numero / (float) outro_numero);
printf(&quot;\n&quot;);
printf(&quot;A divis√£o inteira entre %f e %f √© %i e o resto dessa divis√£o √© %i\n&quot;, 
   numero, outro_numero, numero / outro_numero, numero % outro_numero);

</code></pre>
<p>E o c√≥digo final ficou assim:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int main (){

   // criando vari√°veis que ser√£o usadas
   int numero, outro_numero; // dessa forma criamos v√°rias vari√°veis do mesmo tipo de uma vez

   // lendo vari√°veis
   printf(&quot;digite um n√∫mero: &quot;);
   scanf(&quot;%i&quot;, &amp;numero);

   printf(&quot;digite outro n√∫mero: &quot;);
   scanf(&quot;%i&quot;, &amp;outro_numero);

   // exibindo vari√°veis
   printf(&quot;\n&quot;);
   printf(&quot;%i + %i = %i\n&quot;, numero, outro_numero, numero + outro_numero);
   printf(&quot;%i - %i = %i\n&quot;, numero, outro_numero, numero - outro_numero);
   printf(&quot;%i * %i = %i\n&quot;, numero, outro_numero, numero * outro_numero);
   printf(&quot;%i / %i = %.2f\n&quot;, numero, outro_numero, (float) numero / (float) outro_numero);
   printf(&quot;\n&quot;);
   printf(&quot;A divis√£o inteira entre %i e %i √© %i e o resto dessa divis√£o √© %i\n&quot;,
   numero, outro_numero, numero / outro_numero, numero % outro_numero);

return 0;
}
</code></pre>
<h3 id="desafio-2"><a class="header" href="#desafio-2">Desafio 2</a></h3>
<p>Fa√ßa uma calculadora na qual o programa pe√ßa dois n√∫meros e depois uma opera√ß√£o (a escolha deve ser entre soma e subtra√ß√£o).</p>
<blockquote>
<p>Sa√≠da:</p>
</blockquote>
<pre><code>Digite um n√∫mero inteiro: 8
Digite outro n√∫mero inteiro: 2
Digite a opera√ß√£o [+/-]: +

A soma entre 8 e 2 √© 10

</code></pre>
<h4 id="resposta-1"><a class="header" href="#resposta-1">Resposta</a></h4>
<p>A primeira coisa que devemos fazer √© obviamente escrever a estrutura padr√£o:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main (){

   return 0;
}
</code></pre>
<p>Agora, temos que declarar as vari√°veis que ir√£o guardar os dados:</p>
<pre><code class="language-c">int numero, outro_numero;
char operacao;
</code></pre>
<p>E temos que pedir os dados para o usu√°rio:</p>
<pre><code class="language-c">printf(&quot;Digite um n√∫mero inteiro: &quot;);
scanf(&quot;%i&quot;, &amp;numero);

printf(&quot;Digite outro n√∫mero inteiro: &quot;);
scanf(&quot;%i&quot;, &amp;outro_numero);

printf(&quot;Digite a opera√ß√£o [+/-]: &quot;);
fflush(stdin);

scanf(&quot;%c&quot;, &amp;operacao);
</code></pre>
<blockquote>
<p>no meu caso ocorreu aquele bug do <code>scanf</code> que eu mencionei no cap√≠tulo de entrada e sa√≠da de dados, mas caso no seu n√£o aconte√ßa apague a linha com o <code>fflush</code>.</p>
</blockquote>
<p>Agora, iremos testar se a opera√ß√£o escolhida foi soma ou subtra√ß√£o e depois salvar o resultado em outra vari√°vel (<code>res</code>):</p>
<pre><code class="language-c">int res = ( operacao == '+' ) ? numero + outro_numero : numero - outro_numero ;
//   ...se operacao for +            some          senao   subtraia
</code></pre>
<p>E finalmente exibimos os resultados:</p>
<pre><code class="language-c">printf ( &quot;a %s entre %i e %i √© %i\n&quot;, 
   ( operacao == '+' ) ? &quot;soma&quot; : &quot;subtra√ß√£o&quot;, 
   numero,
   outro_numero,
   res
);
</code></pre>
<p>O c√≥digo final ficou assim:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main (){

   // declarando vari√°veis
   int numero, outro_numero;
   char operacao = '+';

   // lendo vari√°veis
   printf(&quot;Digite um n√∫mero inteiro: &quot;);
   scanf(&quot;%i&quot;, &amp;numero);

   printf(&quot;Digite outro n√∫mero inteiro: &quot;);
   scanf(&quot;%i&quot;, &amp;outro_numero);

   printf(&quot;Digite a opera√ß√£o [+/-]: &quot;);
   // resolvendo bug do scanf
   scanf(&quot;%c&quot;, &amp;operacao);
   // lendo vari√°vel
   scanf(&quot;%c&quot;, &amp;operacao);

   // calculando resultado
   int res = ( operacao == '+' ) ? numero + outro_numero : numero - outro_numero ;
   //   ...se operacao for +            some          senao   subtraia

   // exibindo resultado
   printf ( &quot;a %s entre %i e %i √© %i\n&quot;, 
         ( operacao == '+' ) ? &quot;soma&quot; : &quot;subtra√ß√£o&quot;, 
         numero, 
         outro_numero, 
         res 
   );

   return 0;
}
</code></pre>
<h3 id="desafio-3"><a class="header" href="#desafio-3">Desafio 3</a></h3>
<p>Fa√ßa um programa que leia 3 n√∫meros e diga quantos deles s√£o √≠mpares ou pares e quantos deles s√£o divis√≠veis por 3 (se divididos por 3 o resto tem que ser 0).</p>
<blockquote>
<p>Sa√≠da:</p>
</blockquote>
<pre><code>Digite 3 n√∫meros: 2 1 3
2 s√£o √≠mpares, 1 √© par e 1 √© divis√≠vel por 3
</code></pre>
<p>Voc√™ j√° deve ter percebido que este √© complicado, mas calma... √â s√≥ pensar bem, e uma dica, explore bem o tern√°rio antes.</p>
<h4 id="resposta-2"><a class="header" href="#resposta-2">Resposta</a></h4>
<p>A primeira coisa que iremos fazer √© declarar e ler os n√∫meros ( depois de escrever a estrutura padr√£o √© claro ) :</p>
<pre><code class="language-c">int n1, n2, n3; // Essa √© a forma de declarar v√°rias vari√°veis ao mesmo tempo

printf (&quot;Digite 3 n√∫meros: &quot;);
scanf (&quot;%i %i %i&quot;, &amp;n1, &amp;n2, &amp;n3);
</code></pre>
<p>Agora n√≥s iremos declarar contadores para os √≠mpares, pares e divis√≠veis por 3 e inici√°-los com <code>0</code> (se n√£o fizer isso suas vari√°veis v√£o receber lixos da mem√≥ria):</p>
<pre><code class="language-c">int impar = 0, par = 0, divPor3 = 0; // essa √© a forma de inicializar v√°rias vari√°veis ao mesmo tempo
</code></pre>
<p>Declarados os contadores, iremos testar os n√∫meros pares e √≠mpares:</p>
<pre><code class="language-c">// se o n√∫mero for divis√≠vel por 2 incremente par sen√£o incremente impar
( n1 % 2 == 0 )? par ++: impar ++;
( n2 % 2 == 0 )? par ++: impar ++;
( n3 % 2 == 0 )? par ++: impar ++;
</code></pre>
<p>Agora testamos os divis√≠veis por 3:</p>
<pre><code class="language-c">divPor3 = ( n1 % 3 == 0 )? divPor3 + 1: divPor3;
divPor3 = ( n2 % 3 == 0 )? divPor3 + 1: divPor3;
divPor3 = ( n3 % 3 == 0 )? divPor3 + 1: divPor3;
</code></pre>
<p>E por fim exibimos os valores:</p>
<p>Aqui n√≥s temos duas op√ß√µes, exibimos os dados de forma pregui√ßosa:</p>
<pre><code class="language-c">printf ( &quot;%i s√£o √≠mpares\n&quot;, impar);
printf ( &quot;%i s√£o pares\n&quot;, par);
printf ( &quot;%i s√£o div√≠veis por 3\n&quot;, divPor3);
</code></pre>
<blockquote>
<p>E nesse caso, quando o contador vale 0 ou 1, vai ficar ‚Äú0 s√£o <algo>‚Äú ou ‚Äú1 s√£o <algo>‚Äú.</p>
</blockquote>
<p>Ou tentamos adaptar a resposta para que ela respeite os plurais e singulares e assim criando um programa mais inteligente:</p>
<blockquote>
<p>Ambos os c√≥digos de exibi√ß√£o dos dados funcionar√£o da mesma forma, basicamente temos que exibir uma resposta assim:</p>
</blockquote>
<blockquote>
<p><code>&lt;contador&gt; &lt;s√£o (se plural)|| √© (se singular)&gt; &lt;info que o contador se refere&gt;</code></p>
</blockquote>
<blockquote>
<p>E caso o contador for <code>0</code> essa resposta tem que ser assim: <code>nenhum √© &lt;info que o contador se refere&gt;</code></p>
</blockquote>
<blockquote>
<p>mas para economizar linhas de c√≥digo essas duas formas de frase teriam que ser uma s√≥, logo, eu temos que montar um esqueleto assim:</p>
</blockquote>
<blockquote>
<p><code>&lt;contador&gt;&lt;caractere auxiliar&gt;&lt;string indicando a quantidade&gt; &lt;info a que o contador se refere&gt;</code></p>
</blockquote>
<blockquote>
<p>Ent√£o a string do <code>printf</code> ficou assim: <code>&quot;%i%c%s %s\n&quot;</code></p>
<p>Agora que temos o ‚Äúesqueleto‚Äù da resposta, temos que dar valores a esses campos e o primeiro √© o contador ( <code>par</code>, <code>impar</code> e <code>divPor3</code> )</p>
<p>O segundo √© o caractere auxiliar e ele tem que apagar o contador caso ele for nulo (igual a <code>0</code>) com o caractere <code>\b</code>, caso contr√°rio ele insere um espa√ßo (‚Äô ‚Äò):</p>
<p><code>( &lt;contador&gt; == 0 ) ? '\b' : ' ' </code></p>
<p>O terceiro √© a string indicando a quantidade, e nesse caso temos tr√™s op√ß√µes, se o contador for 0 essa string tem que ser <code>&quot;nenhum √©&quot;</code>, se o contador n√£o for <code>0</code> ele testa se o contador √© igual a 1, e caso for verdadeiro essa string vai valer <code>&quot;√©&quot;</code> (indicando que √© singular), sen√£o ele obviamente √© plural (contador maior que <code>1</code>) ent√£o essa string vai valer <code>&quot;s√£o&quot;</code>:</p>
<p><code>(&lt;contador&gt; == 0)? &quot;nenhum √©&quot; : ( ( &lt;contador&gt; == 1 )? &quot;√©&quot; : &quot;s√£o&quot; )</code>.</p>
<p>Por fim √© s√≥ testar se √© plural ou singular e colocar a informa√ß√£o a que o contador se refere no plural ou singular:</p>
<p><code>(&lt;contador&gt; &gt; 1)? &lt;info no plural&gt; : &lt;info no singular&gt;</code></p>
</blockquote>
<blockquote>
<p>O ‚Äúesqueleto‚Äù final do printf ficou assim:</p>
</blockquote>
<pre><code class="language-c">printf ( &quot;%i%c%s %s&quot;,
         &lt;contador&gt;,                                              // %i
         (&lt;contador&gt; == 0)? '\b' : ' ',                           // %c
         (&lt;contador&gt; == 0)? &quot;nenhum √©&quot; :
               ( ( &lt;contador&gt; == 1 )? &quot;√©&quot; : &quot;s√£o&quot; ),              // %s
         (&lt;contador&gt; &gt; 1)? &lt;info no plural&gt; : &lt;info no singular&gt;  // %s
);
</code></pre>
<p>E √© assim que fica a exibi√ß√£o dos resultados seguindo o esqueleto acima:</p>
<pre><code class="language-c">// Hora de exibir os resultados

printf(
   &quot;%i%c%s %s,&quot;, 

   impar,
   (impar == 0 )? '\b' : ' ',

   (impar == 0 )?  &quot;nenhum √©&quot; :
      ( (impar == 1 )? &quot;√©&quot; : &quot;s√£o&quot; ) ,

   (impar &gt; 1)? &quot;√≠mpares&quot;: &quot;√≠mpar&quot;
);

printf(
   &quot; %i%c%s %s&quot;, 

   par,
   (par == 0 )? '\b' : ' ',
   (par == 0 )? &quot;nenhum √©&quot; :
      ( (par == 1 )? &quot;√©&quot; : &quot;s√£o&quot; ),

   (par &gt; 1)? &quot;pares&quot;: &quot;par&quot;
);

printf(
   &quot; e %i%c%s %s\n&quot;, 

   divPor3,
   (divPor3 == 0 )? '\b' : ' ',

   (divPor3 == 0 )? &quot;nenhum √©&quot; :
      ( (divPor3 == 1 )? &quot;√©&quot; : &quot;s√£o&quot; ),

   (divPor3 &gt; 1)? &quot;divis√≠veis por 3&quot;: &quot;divis√≠vel por 3&quot;
);
</code></pre>
<p>E o c√≥digo final ficou assim:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main(int argc, char **argv){

   // declara√ß√£o e leitura de vari√°veis
   int n1, n2, n3;

   printf (&quot;Digite 3 n√∫meros: &quot;);
   scanf (&quot;%i %i %i&quot;, &amp;n1, &amp;n2, &amp;n3);

   // declara√ß√£o e inicializa√ß√£o dos contadores
   int impar = 0, par = 0, divPor3 = 0;

   // se o n√∫mero for divis√≠vel por 2 incremente par sen√£o incremente impar
   ( n1 % 2 == 0 )? par ++: impar ++;
   ( n2 % 2 == 0 )? par ++: impar ++;
   ( n3 % 2 == 0 )? par ++: impar ++;

   // se √© divis√≠vel por 3 incremente sen√£o n√£o incremente
   divPor3 = ( n1 % 3 == 0 )? divPor3 + 1: divPor3;
   divPor3 = ( n2 % 3 == 0 )? divPor3 + 1: divPor3;
   divPor3 = ( n3 % 3 == 0 )? divPor3 + 1: divPor3;

   // Hora de exibir os resultados

   printf(
      &quot;%i%c%s %s&quot;, 

      impar,
      (impar == 0 )? '\b' : ' ',

      (impar == 0 )?  &quot;nenhum √©&quot; :
         ( (impar == 1 )? &quot;√©&quot; : &quot;s√£o&quot; ) ,

      (impar &gt; 1)? &quot;√≠mpares&quot;: &quot;√≠mpar&quot;
   );

   printf(
      &quot;%i%c%s %s&quot;, 

      par,
      (par == 0 )? '\b' : ' ',
      (par == 0 )? &quot;nenhum √©&quot; :
         ( (par == 1 )? &quot;√©&quot; : &quot;s√£o&quot; ),

      (par &gt; 1)? &quot;pares&quot;: &quot;par&quot;
   );

   printf(
      &quot; e %i%c%s %s\n&quot;, 

      divPor3,
      (divPor3 == 0 )? '\b' : ' ',

      (divPor3 == 0 )? &quot;nenhum √©&quot; :
         ( (divPor3 == 1 )? &quot;√©&quot; : &quot;s√£o&quot; ),

      (divPor3 &gt; 1)? &quot;divis√≠veis por 3&quot;: &quot;divis√≠vel por 3&quot;
   );

   return 0;
}
</code></pre>
<h3 id="desafio-4"><a class="header" href="#desafio-4">Desafio 4</a></h3>
<p>Fa√ßa um programa que leia 3 n√∫meros e diga qual √© o maior e qual √© o menor, e se a pessoa digitar n√∫meros iguais, ele tem que avisar ‚Äúforam digitados n√∫meros iguais‚Äù.</p>
<blockquote>
<p>Sa√≠da:</p>
</blockquote>
<pre><code>Digite 3 n√∫meros:2
3
3

O n√∫mero 1 √© o menor
O n√∫mero 3 √© o maior

foram digitados n√∫meros iguais
</code></pre>
<p>Este voc√™ tem que fazer sozinho, todas as coisas necess√°rias para faz√™-lo foram ensinadas. Boa sorte e se n√£o conseguir fazer, releia os cap√≠tulos anteriores com muito cuidado, e depois tente de novo.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arrays-e-strings"><a class="header" href="#arrays-e-strings">Arrays e Strings</a></h1>
<h2 id="arrays"><a class="header" href="#arrays">Arrays</a></h2>
<p>Arrays s√£o vari√°veis com v√°rios espa√ßos... <em>‚ÄúComo assim?‚Äù</em> ... Lembra do arm√°rio das vari√°veis? No caso do array, em vez de reservar um espa√ßo, voc√™ pede v√°rios espa√ßos de uma vez, tipo:</p>
<blockquote>
<p><code>cubo dado [] com </code> :game_die:<code>,</code>:game_die:<code>,</code>:game_die:<code> dentro</code></p>
</blockquote>
<pre><code class="language-c">int algarismos [] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 0 };
</code></pre>
<p>E tamb√©m √© poss√≠vel acessar um item espec√≠fico do array adicionando a posi√ß√£o entre <code>[</code> e <code>]</code>.</p>
<pre><code class="language-c">int algarismos [] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0};

int tres = algarismos[2]
</code></pre>
<p>Agora, a vari√°vel <code>tres</code> est√° com o item <code>3</code>, <em>‚ÄúMas o 3 est√° da 3¬∫ posi√ß√£o!‚Äù</em> , eu entendo, esse √© um erro que todo iniciante comete, a quest√£o √© que a contagem come√ßa do <code>0</code>:</p>
<pre><code class="language-c">//                    [0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
int algarismos [] = {  1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 0};
</code></pre>
<p>E desta forma √© poss√≠vel modificar um valor do array:</p>
<pre><code class="language-c">algarismos[9] = 9;
</code></pre>
<p>Mas para modificar o array inteiro √© necess√°rio modificar item por item, portanto, a seguinte forma n√£o funcionar√°:</p>
<pre><code class="language-c">int algarismos [] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0};

algarismos = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
</code></pre>
<p>Os arrays n√£o podem ser impressos ou atribu√≠dos, isso significa que todos os itens tem de ser imprimidos um por um:</p>
<pre><code class="language-c">a [] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

printf (
   &quot;%i, %i, %i, %i, %i, %i, %i, %i, %i, %i\n&quot;,
   a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[0]
);
</code></pre>
<p>E antes que algu√©m pergunte <em>‚ÄúS√≥ existe array inteiro?‚Äù</em>, n√£o, voc√™ pode fazer arrays com qualquer tipo primitivo.</p>
<p>Se voc√™ prestou aten√ß√£o no cap√≠tulo sobre vari√°veis voc√™ deve conhecer o comando <code>sizeof</code>, que diz a quantidade de bytes de uma vari√°vel, se voc√™ usar com arrays tamb√©m:</p>
<pre><code class="language-c">int i [3];
printf (&quot;o tamanho de &quot;i&quot; √© %i&quot;, sizeof i);
</code></pre>
<p><em>‚ÄúMas e se eu quiser saber a quantidade de elementos do meu array?‚Äù</em> ... voc√™ s√≥ precisa dividir o tamanho do array pelo tamanho do tipo desse array... <em>‚ÄúComo assim?‚Äù</em> ... O tamanho de uma vari√°vel <code>int</code> √© o mesmo do tipo <code>int</code>, logo, o tamanho do tipo √© o tamanho de uma vari√°vel com esse tipo...</p>
<pre><code class="language-c">int i;
int array_i [8];

int tmh_i = sizeof i;           // tamanho de i
int tmh_ari = sizeof array_i;   // tamanho de array_i

int qnt_elem = tmh_ari / tmh_i; // quantidade de elementos
</code></pre>
<p>Ou, se voc√™ for pregui√ßoso igual eu:</p>
<pre><code class="language-c">int array_i [8];

int qnt_elem = sizeof array_i / sizeof array_i[0]; // quantidade de elementos
</code></pre>
<blockquote>
<p>lembrem-se de que <code>array_i</code> √© um array do tipo <code>int</code>, ou seja, tem elementos do tipo <code>int</code>, logo, se eu usar o tamanho de um desses elementos eu tamb√©m vou ter acesso ou tamanho do tipo...</p>
</blockquote>
<h2 id="strings"><a class="header" href="#strings">Strings</a></h2>
<p>Uma string √© uma cadeia de caracteres ou um array de caracteres ou um ‚Äúvetor‚Äù de caracteres.</p>
<p><em>‚ÄúMas se √© um array, por que eu preciso ler essa parte se voc√™ j√° explicou os arrays?‚Äù</em> ... Muito simples, as strings s√£o arrays e possuem todas as caracter√≠sticas de arrays, mas elas t√™m algumas particularidades.</p>
<pre><code class="language-c">char Char = 'A';          // isso √© um caractere
char String [] = &quot;coisa&quot;; // isso √© uma cadeia de caracteres

// essa √© a maneira de tradicional de escrever a string
char other_str [] = {'c', 'o', 'i', 's', 'a', '\0'};
</code></pre>
<blockquote>
<p>tanto a vari√°vel <code>String</code> quanto a <code>other_str</code> s√£o strings, mas, caso voc√™ use a segunda forma, n√£o se esque√ßa do <code>\0</code> no fim, pois este caractere √© o que delimita o fim de uma string.</p>
</blockquote>
<p>Caso n√£o queira dar valor para a string, voc√™ dever√° dizer qual o seu tamanho (assim como em qualquer outro tipo de array), exemplo:</p>
<pre><code class="language-c">char String [10];
</code></pre>
<blockquote>
<p>Caso voc√™ necessite usar a forma acima, lembre-se de colocar um numero a mais no comprimento da string, pois o √∫ltimo caractere √© reservado para simbolizar o fim de uma string, por isso esta string s√≥ tem 9 caracteres v√°lidos.</p>
</blockquote>
<p><em>‚ÄúT√°, mas como eu dou um valor para ela?‚Äù</em> ... Voc√™ pode fazer isso de tr√™s maneiras.</p>
<p>A primeira forma √© a tradicional para dar valores a um array:</p>
<pre><code class="language-c">char s [13];

s[0] = 'c';
s[1] = 'o';
s[2] = 'i';
s[3] = 's';
s[4] = 'a';
s[5] = 's';
s[6] = '\0';
</code></pre>
<blockquote>
<p>E s√≥ pra relembrar: N√ÉO SE ESQUE√áA DO <code>\0</code>... T√¥ parecendo at√© flashback de naruto com esse caractere ...</p>
</blockquote>
<p>Na segunda, voc√™ tem que importar a biblioteca <code>string.h</code> e depois usar a fun√ß√£o <code>strcpy</code> para atribuir o valor, dessa maneira:</p>
<pre><code class="language-c">#include &lt;string.h&gt;

char str[13];
strcpy(str, &quot;coisas&quot;);
</code></pre>
<blockquote>
<p>O <code>include</code> acima pode ficar tanto dentro da fun√ß√£o <code>main</code> quanto fora, s√≥ √© importante colocar antes do uso da fun√ß√£o <code>strcpy</code>.</p>
</blockquote>
<p>E a terceira, voc√™ vai ter que esperar pelo cap√≠tulo de ponteiros para entender, logo, use as mostradas acima por enquanto.</p>
<p>Note que voc√™ n√£o √© obrigado a colocar a quantidade exata de caracteres na string, mas n√£o coloque uma string maior que o tamanho tamanho estipulado.</p>
<p><em>‚ÄúLegal, mas se eu quiser ler uma string? Ou imprimir uma string?‚Äù</em> ... Muito simples, √© s√≥ usar o <code>%s</code> no <code>scanf</code> e no <code>printf</code>, mas em rela√ß√£o ao <code>scanf</code> temos uma leve diferen√ßa:</p>
<pre><code class="language-c">char str [20];
scanf(&quot;%s&quot;, &amp;str);

printf(&quot;a string lida foi: %s\n&quot;, str);
</code></pre>
<p>Uma coisa que eu sei que voc√™ ficou na d√∫vida no cap√≠tulo sobre vari√°veis foi o por que de <code>'A'</code> ser diferente de <code>&quot;A&quot;</code>.</p>
<pre><code class="language-c">char Char = 'A';
char String = &quot;A&quot;;
</code></pre>
<p>‚ÄòA‚Äô √© diferente de ‚ÄúA‚Äù, pois a string tem sempre um caractere nulo no fim:</p>
<table><thead><tr><th></th><th>[0]</th><th>[1]</th></tr></thead><tbody>
<tr><td>Char</td><td>‚ÄòA‚Äô</td><td></td></tr>
<tr><td>String</td><td>‚ÄòA‚Äô</td><td>‚Äò\0‚Äô</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="escopo-e-condicionais"><a class="header" href="#escopo-e-condicionais">Escopo e Condicionais</a></h1>
<h2 id="os-blocos-e-o-escopo"><a class="header" href="#os-blocos-e-o-escopo">Os blocos e o escopo</a></h2>
<p>At√© agora eu apenas mencionei o que √© um bloco l√° no inicio do livro para explicar a fun√ß√£o <code>main</code>, mas acho que aquilo n√£o foi o suficiente para encerrar o assunto.</p>
<p>A primeira caracter√≠stica de um bloco, que a prop√≥sito j√° foi abordada, √© que ele √© uma sequencia de comandos entre <code>{</code> e <code>}</code>, mas uma coisa que voc√™ n√£o sabia √© que ele pode ser usado sem a necessidade de uma estrutura:</p>
<pre><code class="language-c">int numero;

{
   numero = 89;
}

numero += 67;
</code></pre>
<p><em>‚Äúmas que diferen√ßa isso fez para o programa?‚Äù</em> , neste caso acima nenhuma, mas os blocos podem ser √∫teis para a organiza√ß√£o do c√≥digo e tamb√©m para o isolamento de vari√°veis:</p>
<pre><code class="language-c">int n = 46;
{
   char a = n;
   printf(&quot;char: %c\n&quot;, a);
}
printf(&quot;char: %c\n&quot;, a);
</code></pre>
<p>O programa a cima n√£o ir√° compilar por que a vari√°vel <code>a</code> s√≥ existe dentro do bloco, logo, o segundo <code>printf</code> n√£o vai conseguir imprimir a vari√°vel.</p>
<p>Isso acontece por causa de uma coisa que chamamos de escopo, e o escopo determina o n√≠vel de acesso de uma vari√°vel no c√≥digo, isso significa a vari√°vel <code>a</code> do c√≥digo anterior s√≥ podia ser acessada dentro do bloco onde foi declarada, e √© o que chamamos de vari√°vel local.</p>
<pre><code class="language-c">int coisa = 0;

int main () {

   int outra_coisa = 90;

   // bloco
   {
      int A = 100;
   }
   return 0;
}
</code></pre>
<p>O escopo do c√≥digo anterior seria assim:</p>
<blockquote>
<p>Trate o ‚ÄúX‚Äù como ‚Äúpode acessar‚Äù o bloco dentro da fun√ß√£o <code>main</code> √© o ‚Äúbloco‚Äù da tabela e tudo o que est√° fora da fun√ß√£o <code>main</code> √© a √°rea ‚Äúglobal‚Äù.</p>
</blockquote>
<table><thead><tr><th></th><th>bloco</th><th><code>main</code></th><th>global</th></tr></thead><tbody>
<tr><td><code>coisa</code></td><td>X</td><td>X</td><td>X</td></tr>
<tr><td><code>outra_coisa</code></td><td>X</td><td>X</td><td></td></tr>
<tr><td><code>A</code></td><td>X</td><td></td><td></td></tr>
</tbody></table>
<blockquote>
<p>A vari√°vel <code>coisa</code> √© global porque est√° fora de todos os blocos poss√≠veis, portanto pode ser acessada em qualquer bloco do programa, enquanto a vari√°vel <code>outra_coisa</code> √© local da fun√ß√£o <code>main</code>, logo, todo e qualquer bloco dentro do <code>main</code> pode ter acesso a ela, e a vari√°vel <code>A</code> s√≥ existe dentro do bloco isolado.</p>
</blockquote>
<pre><code class="language-c">int a = 78973;
{
   char a = 'a';
   printf(&quot;char a : %c\n&quot;, a);
}
printf(&quot;int a : %i\n&quot;, a);
</code></pre>
<blockquote>
<p>Sa√≠da:</p>
</blockquote>
<pre><code>char a : a
int a : 78973
</code></pre>
<blockquote>
<p>O que aconteceu aqui foi que a vari√°vel <code>a</code> do tipo inteiro foi declarada fora do bloco, logo, ela existia tamb√©m dentro do bloco, at√© que outra vari√°vel <code>a</code> foi declarada dentro do bloco tamb√©m, e o valor do <code>a</code> de dentro do bloco n√£o sob-escreve o <code>a</code> de fora do bloco porque ela s√≥ existe dentro do bloco, e quando o bloco acaba a vari√°vel <code>a</code> do tipo <code>char</code> deixa de existir e o <code>a</code> inteiro continua existindo...</p>
</blockquote>
<p>Eu sei que √© um pouco confuso, mas isso acontece simplesmente por que as vari√°veis de escopos diferentes s√£o declaradas √°reas diferentes da mem√≥ria.</p>
<p>E nunca se esque√ßa que essas regras vistas neste cap√≠tulo serve para todo e qualquer bloco...</p>
<h2 id="condicionais"><a class="header" href="#condicionais">Condicionais</a></h2>
<p>At√© agora n√≥s fizemos c√≥digos mais sequenciais, onde todos os comandos eram executados e a √∫nica forma de decis√£o que usamos foi o operador tern√°rio.</p>
<pre><code class="language-c">int n;

printf(&quot;digite um n√∫mero: &quot;);
scanf(&quot;%i&quot;, &amp;n);

// com o tern√°rio
printf(&quot;o n√∫mero %i √© %s &quot;, n, (  n % 2 == 0   ) ?     &quot;par&quot;    :  &quot;√≠mpar&quot;   );
//                             (opera√ß√£o l√≥gica) ? caso verdade : caso falso

// com condicionais
printf(&quot;o n√∫mero %i √© &quot;, n)
if (n % 2 == 0) {         // se n for par
   printf(&quot;par \n&quot;);      //   escreva &quot;par&quot;
} else {                  // sen√£o
   printf(&quot;√≠mpar \n&quot;);    //   escreva &quot;√≠mpar&quot;
}
</code></pre>
<p>Note que os condicionais s√£o muito mais intuitivos, e por isso s√£o mais f√°ceis de usar que o tern√°rio... <em>‚ÄúU√©? Ent√£o por que voc√™ mostrou o tern√°rio primeiro?‚Äù</em> ...Porque eu precisava de uma estrutura que n√£o exigisse um conhecimento sobre blocos e escopo e que tornasse o voc√™ mais preparado para esse assunto, pois se voc√™ entendeu o tern√°rio voc√™ com certeza entendeu os condicionais.</p>
<p><em>‚ÄúMas com o tern√°rio ficou muito mais curto!‚Äù</em> ...Sim, mas e se sempre que o n√∫mero for √≠mpar ele tenha tamb√©m de pedir outro n√∫mero ao usu√°rio?...</p>
<blockquote>
<p>N√£o se questione sobre esta funcionalidade a mais, ela √© s√≥ uma forma de dificultar um pouco o exemplo.</p>
</blockquote>
<pre><code class="language-c">// com tern√°rio
int n;

printf(&quot;digite um n√∫mero: &quot;);
scanf(&quot;%i&quot;, &amp;n);

   (  n % 2 == 0  )? printf(&quot;o n√∫mero %i √© par&quot;, n) : printf(&quot;digite outro n√∫mero: &quot;);
//   se n for par         diga que ele √© par      sen√£o        pe√ßa outro n√∫mero

int reserva = n;
n = ( n % 2 == 0 ) ?   n       :      scanf(&quot;%i&quot;, &amp;reserva);
//   se n for par    n √© n   sen√£o      leia outro n√∫mero

n = reserva;
</code></pre>
<blockquote>
<p>antes que voc√™ se pergunte o por qu√™ de eu ter criado a vari√°vel <code>reserva</code>, se o c√≥digo estivesse assim:</p>
</blockquote>
<pre><code class="language-c">n = ( n % 2 == 0 ) ? n : scanf(&quot;%i&quot;, &amp;n);
</code></pre>
<blockquote>
<p>O <code>scanf</code> iria ler o valor, colocar dentro do n, mas quando ele finalizasse esta instru√ß√£o ele retornaria um <code>1</code> ou um <code>0</code> para informar se deu certo ou n√£o, e esse feedback do <code>scanf</code> substituiria o valor lido por ele, e sempre que o n√∫mero fosse √≠mpar o <code>n</code> seria <code>1</code> ou <code>0</code>, ent√£o a vari√°vel <code>reserva</code> serve de reserva para o valor de <code>n</code>.</p>
</blockquote>
<pre><code class="language-c">// com condicionais
int n;

printf(&quot;digite um n√∫mero: &quot;);
scanf(&quot;%i&quot;, &amp;n);

if (n % 2 == 0) {                    // se n for par
   printf(&quot;o n√∫mero %i √© par&quot;, n);   // diga que ele √© par
} else {                             // sen√£o
   printf(&quot;digite outro n√∫mero: &quot;);  // pe√ßa outro n√∫mero
   scanf(&quot;%i&quot;, &amp;n);                  // e leia esse n√∫mero
}
</code></pre>
<p>Note que o c√≥digo feito com condicionais ficou muito mais organizado e simples de entender, al√©m de eliminar a necessidade da vari√°vel auxiliar <code>reserva</code>...</p>
<p>Existem 3 formas de fazer um condicional no C:</p>
<pre><code class="language-c">int condicao = (67 != 5);  /*
                              e se voc√™ prestou aten√ß√£o 
                              no cap√≠tulo de operadores 
                              sabe que o valor dessa 
                              vari√°vel √© 1.
                           */
int outra_condicao = (8 &gt; 2);

// simples

if ( condicao ) {
   // comandos
}

// composto
if ( condicao ) {
   // comandos
else {
   // outros comandos
}

// aninhado
if ( condicao ) {
   // comandos
else if ( outra_condicao ) {
   // comandos
} else {
   // outros comandos
}
</code></pre>
<blockquote>
<p>Mas o bloco n√£o √© obrigat√≥rio para o uso do condicional, caso voc√™ queira um <code>if</code> mais compacto:</p>
</blockquote>
<pre><code class="language-c">if (condicao) /* comando */;
</code></pre>
<blockquote>
<p>Caso voc√™ precise executar mais de um comando voc√™ vai ter que usar um bloco, mas voc√™ usar a forma acima em conjunto com as anteriores, logo, o seguinte c√≥digo √© v√°lido:</p>
</blockquote>
<pre><code class="language-c">int i = 3847;

if (i % 2 == 0) printf(&quot;O n√∫mero √© par!\n&quot;);

else if ( ( (float) i / 3.0 == 0.0 ) &amp;&amp; ( i % 2 == 1 ) ) {
   printf(&quot;O n√∫mero √© √≠mpar e divis√≠vel por 3!&quot;);
   printf(&quot;\n&quot;);
}

else printf(&quot;O n√∫mero √© √≠mpar!&quot;);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="estruturas-de-repeti√ß√£o"><a class="header" href="#estruturas-de-repeti√ß√£o">Estruturas de repeti√ß√£o</a></h1>
<p>Estruturas de repeti√ß√£o s√£o estruturas que permitem que voc√™ repita comandos, e isso te permite automatizar algumas coisas como atribuir valor a arrays ou fazer contagem...</p>
<h2 id="while"><a class="header" href="#while">While</a></h2>
<pre><code class="language-c">// exibindo uma contagem at√© 5

// sem estruturas de repeti√ß√£o
printf(&quot;%i\n&quot;, 1);
printf(&quot;%i\n&quot;, 2);
printf(&quot;%i\n&quot;, 3);
printf(&quot;%i\n&quot;, 4);
printf(&quot;%i\n&quot;, 5);

// com uma estrutura de repeti√ß√£o
int contador = 1;
while (contador &lt;= 5){          // enquanto o contador for menor ou igual 5
   printf(&quot;%i\n&quot;, contador);    //   escreva o contador
   contador ++;                 //   e incremente o contador
}
</code></pre>
<blockquote>
<p>No caso acima temos duas formas de exibir uma contagem... <em>‚ÄúMas deu a mesma quantidade de linhas, ent√£o n√£o vale a pena aprender esse neg√≥cio dif√≠cil a√≠, a primeira op√ß√£o √© mais simples!!‚Äù</em> ... E se ao inv√©s de contar at√© 5 n√≥s precis√°ssemos contar at√© mil? Voc√™ ainda acha aceit√°vel escrever isso sem usar uma estrutura de repeti√ß√£o ?</p>
</blockquote>
<p>A estrutura usada √© o <code>while</code>, que significa ‚Äúenquanto‚Äù, basicamente ele funciona assim:</p>
<pre><code class="language-c">condicao = (2 != 3);
while ( condicao ) {   // enquanto a condi√ß√£o for verdade execute
   // comandos
}
</code></pre>
<p>E se a condi√ß√£o for verdadeira o <code>while</code> vai executar os comandos do bloco, mas se ela for falsa ele vai sair do loop (estrutura de repeti√ß√£o).</p>
<p>E assim como nos condicionais, se voc√™ precisar</p>
<p>No caso da contagem foi necess√°rio adicionar <code>1</code> ao contador, pois se a <code>condicao</code> sempre for verdadeira o programa vai entrar em um loop infinito, e foi isso que aconteceu com o nosso exemplo anterior, pois o <code>2</code> sempre ser√° diferente do <code>3</code>.</p>
<p>Mas isso n√£o quer dizer que loops infinitos sejam sempre ruins,Digamos que agente queira que um programa leia dados, mas n√£o sabemos a quantidade exata de vezes ler, ent√£o criamos um loop infinito e damos um ‚Äúflag‚Äù(uma forma de interrup√ß√£o do loop) a ele, no nosso exemplo flag ser√° a resposta para a pergunta ‚ÄúDeseja continuar?‚Äù, caso a pessoa digite ‚Äún‚Äù loop ser√° interrompido.</p>
<p>Eu vou ilustrar a situa√ß√£o acima de duas maneiras usando o <code>while</code>.</p>
<pre><code class="language-c">// usando o teste l√≥gico do while
{
   char flag = 's';

   while (flag == 's'){
      printf(&quot;Deseja continuar? [s/N] &quot;);
      scanf(&quot;%c&quot;, &amp;flag);
   }
}

// usando o break
{
   char flag;

   while (1) {
      printf(&quot;Deseja continuar? [s/N] &quot;);
      scanf(&quot;%c&quot;, &amp;flag);

      if (flag != 's') break; // se a resposta for n√£o interrompa
   }
}
</code></pre>
<blockquote>
<p>O break √© um comando que interrompe loops</p>
</blockquote>
<p>E assim como nos condicionais o <code>while</code> tamb√©m tem uma forma compacta:</p>
<pre><code class="language-c">int cont = 0;
while (cont &lt;= 10) printf(&quot;%i\n&quot;, cont++);
</code></pre>
<h2 id="dowhile"><a class="header" href="#dowhile">Do..while</a></h2>
<p>A estrutura popularmente conhecida como <code>do</code>..<code>while</code> √© basicamente um <code>while</code> de cabe√ßa para baixo.</p>
<pre><code class="language-c">// exibindo uma contagem at√© 5
int i = 1;

// while

while ( i &lt;= 5 )         // enquanto ( i menor ou igual a 5 )
   printf ( &quot;%i\n&quot;, i++ );  //     escreva i

// do..while
do {                         // fa√ßa {
   printf ( &quot;%i\n&quot;, i );     //    escreva i
} while ( i&lt;=5 );            // } enquanto ( i menor ou igual a 5 )
</code></pre>
<p>O <code>do</code>..<code>while</code> funciona da mesma forma que o <code>while</code>, com uma √∫nica diferen√ßa, ele faz o teste l√≥gico no final, logo, ele executa o que est√° no bloco e s√≥ depois testa a condi√ß√£o:</p>
<pre><code class="language-c">int i = 90;

do {
   printf(&quot;%i\n&quot;, i);
} while ( i &lt;= 10 );
</code></pre>
<blockquote>
<p>Sa√≠da:</p>
</blockquote>
<pre><code>90
</code></pre>
<p><em>‚ÄúU√©? Por que ele imprimiu?‚Äù</em> , Porque ele faz o teste l√≥gico ( <code>i &lt;= 10</code> ) no fim da execu√ß√£o do bloco, se este fosse um <code>while</code> comum o teste seria feito antes, e s√≥ executaria o bloco se este teste fosse verdadeiro.</p>
<p><em>‚ÄúAah! Ent√£o √© in√∫til usar este la√ßo!!‚Äù</em> ... Sinto discordar, mas este la√ßo foi criado para agilizar algumas tarefas, lembra do c√≥digo com flag? Que vimos no cap√≠tulo anterior?</p>
<pre><code class="language-c">char flag = 's';

while (flag == 's'){
   printf(&quot;Deseja continuar? [s/N] &quot;);
   scanf(&quot;%c&quot;, &amp;flag);
}
</code></pre>
<p>Para que o c√≥digo acima funcione n√≥s somos obrigados o valor <code>'s'</code> √† vari√°vel <code>flag</code>, com o <code>do</code>..<code>while</code> isso n√£o √© necess√°rio:</p>
<pre><code class="language-c">char flag;

do {
   printf(&quot;Deseja continuar? [s/N] &quot;);
   scanf(&quot;%c&quot;, &amp;flag);
} while (flag == 's');
</code></pre>
<p>E o c√≥digo com <code>while</code> e sem usar o teste l√≥gico (o que usamos o <code>break</code> para sair do loop) √© um <code>do</code>..<code>while</code> escrito manualmente!</p>
<h2 id="for"><a class="header" href="#for">For</a></h2>
<p>O <code>for</code> √© uma forma mais automatizada de loop, ele √© mais usado para contagem, mas tamb√©m √© poss√≠vel us√°-lo com flag.</p>
<p>Em uma compara√ß√£o direta com o <code>while</code>:</p>
<pre><code class="language-c">// exibindo uma contagem at√© 5

// while
{
   int i = 0;
   while (i &lt;= 5) printf(&quot;%i\n&quot;, i++);
}

// for
{
   for ( int i = 0; i &lt;= 5; i++) printf(&quot;%i\n&quot;, i);
}
</code></pre>
<p><em>‚ÄúCaramba!! O que aconteceu aqui?‚Äù</em> ... Se voc√™ n√£o estiver entendido o c√≥digo acima eu irei mostrar da forma tradicional:</p>
<pre><code class="language-c">// exibindo uma contagem at√© 5

// while
{
   int i = 0;            // dando o valor 0 a i
   while (i &lt;= 5) {      // enquanto i menor ou igual a 5
      printf(&quot;%i\n&quot;, i); // escreva i
      i ++;              // incremente i
   }
}

// for
{
   for ( int i   =   0; i &lt;= 5;     i++      ) { 
// para      i entre 0    e  5  incremente i
      printf(&quot;%i\n&quot;, i); 
   }
}
</code></pre>
<p><em>‚ÄúAinda n√£o entendi o <code>for</code>‚Äú</em> ... Note que temos tr√™s espa√ßos entre os parenteses separados por <code>;</code>, no primeiro espa√ßo voc√™ declara uma vari√°vel, no segundo voc√™ digita o teste l√≥gico, e no terceiro voc√™ digita um incremento.</p>
<p>Basicamente o <code>for</code> √© uma gambiarra do <code>while</code>, ainda utilizando o exemplo anterior observe um for escrito no estilo se um <code>while</code>:</p>
<pre><code class="language-c">int i = 0;

for ( ; i &lt;= 5 ; ){
   printf(&quot;%i\n&quot;, i);
   i++;
}
</code></pre>
<blockquote>
<p>Os espa√ßos entre <code>;</code> podem ficar em branco, mas convenhamos que √© um tanto in√∫til usar um <code>for</code> desta maneira...</p>
</blockquote>
<p>E as formas diversas de usar o <code>for</code> s√£o essas:</p>
<pre><code class="language-c">// usar vari√°vel j√° existente
int i;
for (i = 1; i &lt;= 5; i++) printf(&quot;%i\n&quot;, i);

// criando vari√°vel local exclusiva para o uso do for
for ( int i = 1; i &lt;= 5; i++) printf(&quot;%i\n&quot;, i);

// forma while
int i = 1;
for ( ; i &lt;= 5; ) printf(&quot;%i\n&quot;, i++);

// forma de loop infinito com flag
int i = 1;
for (;;) {
   printf (&quot;%i\n&quot;, i++);
   if ( i == 5 ) break;
}
</code></pre>
<p>Deu pra perceber que o <code>for</code> √© bem ecl√©tico n√£o √© mesmo? Mas definitivamente a forma em que ele √© mais √∫til √© a tradicional:</p>
<pre><code class="language-c">for ( int &lt;nome da vari√°vel&gt; = &lt;valor inicial&gt;; &lt;teste l√≥gico&gt;; &lt;incremento&gt;) {
   // comandos
}

// forma compacta
for ( int &lt;nome da vari√°vel&gt; = &lt;valor inicial&gt;; &lt;teste l√≥gico&gt;; &lt;incremento&gt;) /* comando */;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fun√ß√µes"><a class="header" href="#fun√ß√µes">Fun√ß√µes</a></h1>
<p>A estrutura de uma fun√ß√£o j√° foi explicada anteriormente de uma forma bastante resumida:</p>
<pre><code class="language-c">int main(){
   printf(&quot;Hello mundo!!&quot;);
return 0;
}
</code></pre>
<p>Basicamente uma fun√ß√£o √© uma rotina, que pode ser usada durante a execu√ß√£o de um c√≥digo, um exemplo √© a fun√ß√£o <code>printf</code>, que nada mais √© do que um conjunto de c√≥digos que escrevem coisas na tela, uma rotina que √© executada sempre que √© chamada.</p>
<p>A estrutura de uma fun√ß√£o √© simples:</p>
<pre><code class="language-c">//  tipo do retorno  nome     parametros
    int              soma ( int n1, int n2) {
      return n1 + n2;
   }

   int main () {
      printf(&quot;%i\n&quot;, soma( 34, 54));
      return 0;
   }
</code></pre>
<blockquote>
<p>Claro que voc√™ pode declarar a quantidade de par√¢metros que quiser.</p>
</blockquote>
<p>E se voc√™ n√£o quiser retornar nenhum valor declare a fun√ß√£o como <code>void</code>.</p>
<p>Mas se voc√™ for criar uma fun√ß√£o, certifique-se de que ela foi declarada antes da fun√ß√£o <code>main</code>, e se mesmo assim voc√™ ainda queira que a sua fun√ß√£o fique depois do <code>main</code>, voc√™ tem que antes declarar a fun√ß√£o:</p>
<pre><code class="language-c">void oi () ;

int main () {
   oi();
   return 0;
}

void oi () {
   printf(&quot;oi!!\n&quot;);
}
</code></pre>
<p>E um extra sobre a fun√ß√£o <code>main</code> √© que √© poss√≠vel receber dados como par√¢metros... <em>‚ÄúComo assim?‚Äù</em> ... Digamos que queremos que o nosso programa escreva coisas na tela...</p>
<blockquote>
<p>Execu√ß√£o do nosso programa:</p>
</blockquote>
<pre><code class="language-sh">./escreva Hello mundo!!
</code></pre>
<blockquote>
<p>Sa√≠da:</p>
</blockquote>
<pre><code>Hello mundo!!
</code></pre>
<p>Os par√¢metros <code>Hello</code> e <code>mundo!!</code> foram passados para a fun√ß√£o <code>main</code> pela linha de comando, e para que agente possa receber e usar esses par√¢metros voc√™ precisa declar√°-los a √°rea de par√¢metros do <code>main</code>.</p>
<pre><code class="language-c">int main (int arg_counter, char * arg_variable []) {

   for (int i = 1; i &lt;= arg_counter; i ++)
      printf(&quot;%s &quot;, arg_variable[i]);

   printf(&quot;\b\n&quot;);
return 0;
}
</code></pre>
<blockquote>
<p>O <code>arg_counter</code> √© a quantidade de argumentos recebidos, o <code>arg_variable</code> √© um par√¢metros com os argumentos, e esses par√¢metros ou argumentos, s√£o strings.</p>
</blockquote>
<blockquote>
<p>No exemplo acima usamos <code>arg_counter</code> e <code>arg_variable</code> para o nome dos par√¢metros, e voc√™ pode usar o que voc√™ quiser, mas a maioria das pessoas usam <code>argc</code> (<code>arg_counter</code>) e <code>argv</code> (<code>arg_variable</code>).</p>
</blockquote>
<p>Por fim, √© sempre interessante saber como seria um ponteiro para uma fun√ß√£o:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int (* Soma) (int n1, int n2);

int somador (int n, int n2){
  return n + n2;
}

int main(){
  Soma = somador;
  printf(&quot;%i + %i = %i&quot;, 2, 3, Soma(2, 3));
return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ponteiros"><a class="header" href="#ponteiros">Ponteiros</a></h1>
<p>Os ponteiros ou pointers no ingl√™s, s√£o vari√°veis que guardam endere√ßos de mem√≥ria.</p>
<p>Lembra do <code>&amp;</code> antes da vari√°vel no <code>scanf</code>?</p>
<pre><code class="language-c">int n;
scanf(&quot;%i&quot;, &amp;n);
</code></pre>
<p>Este <code>&amp;</code> indica um endere√ßo de mem√≥ria da vari√°vel <code>n</code>, e para guardar este endere√ßo em uma vari√°vel, √© necess√°rio que agente crie um ponteiro:</p>
<pre><code class="language-c">int n = 9;
int * ponteiro_n = &amp;n;
</code></pre>
<p>Este <code>*</code> antes do nome da vari√°vel diz para o C que esta vari√°vel vai guardar endere√ßos de mem√≥ria... <em>‚ÄúMas porque colocar um tipo se a vari√°vel vai guardar s√≥ endere√ßos? Por acaso endere√ßo tem tipo?</em> ... N√£o √© bem assim, temos que dar um tipo ao ponteiro porque ele tamb√©m tem tamanho, e para que consiga armazenar o endere√ßo de uma vari√°vel ele tem que ter o mesmo tamanho.</p>
<p><em>‚ÄúT√°, mas ainda n√£o entendi a utilidade desse neg√≥cio!‚Äù</em> , acho que essa mentalidade vai mudar assim que voc√™ descobrir que um array √© um ponteiro que aloca v√°rios espa√ßos na mem√≥ria.</p>
<p>Existem algumas regras sobre o uso de ponteiros, por exemplo:</p>
<pre><code class="language-c">int i = 90;

int * p = &amp;i; // o ponteiro &quot;p&quot; agora aponta para a vari√°vel &quot;i&quot;

printf(&quot;%i\n&quot;, *p);
</code></pre>
<blockquote>
<p>Quando damos o endere√ßo de mem√≥ria de uma vari√°vel para um ponteiro, n√≥s dizemos que esse ponteiro aponta para essa vari√°vel</p>
</blockquote>
<p>No exemplo acima, declaramos um ponteiro <code>p</code> apontando para <code>i</code>, agora n√≥s podemos ter acesso ao valor de <code>i</code> apenas adicionando um <code>*</code> antes do <code>p</code>, e com isso conseguimos exibir o valor de <code>i</code> na tela com o <code>printf</code>.</p>
<p>E usando esse <code>*</code> tamb√©m podemos alterar o valor de <code>i</code>:</p>
<pre><code class="language-c">int i = 90;

int * p = &amp;i;
*p = 89;
</code></pre>
<blockquote>
<p>S√≥ que n√≥s estamos alterando o valor diretamente na mem√≥ria, e uma prova disso √© que se voc√™ incrementar o ponteiro <code>p</code>, ter√° acesso a outro endere√ßo de mem√≥ria.</p>
</blockquote>
<pre><code class="language-c">int i = 90;
int * p = &amp;i;

p ++;

*p = 89;
</code></pre>
<p>Quando voc√™ executar o c√≥digo acima ir√° ocorrer um erro de segmenta√ß√£o (quando o programa tenta acessar uma mem√≥ria que n√£o pertence a ele) ou se n√£o ocorrer erro, quer dizer que ele acessou um espa√ßo de mem√≥ria desconhecido, e quando este ultimo ocorre o valor que est√° nesse espa√ßo √© um lixo do sistema ou o local onde est√° alocada outra vari√°vel.</p>
<pre><code class="language-c">int a[] = { 2, 4, 5, 6};

printf(&quot;%i\n&quot;, a[1]); // 4

a ++;
printf(&quot;%i\n&quot;, * a);  // 4
</code></pre>
<p>Como um array √© um ponteiro, n√≥s podemos usar o array como um ponteiro, <em>‚ÄúMas por que voc√™ incrementou o <code>a</code> antes de exibi-lo?‚Äù</em> , porque se eu us√°-se o endere√ßo original, o valor exibido seria o <code>2</code>, pois o endere√ßo de mem√≥ria sempre se refere ao primeiro valor.</p>
<p>Mas o m√©todo que usei anteriormente n√£o √© muito adequado j√° que uma vez que voc√™ incremente o array ele estar√° apontando para outra posi√ß√£o e assim voc√™ tem que decrementar toda vez, o que n√£o √© pr√°tico, ent√£o, a forma mais indicada para isso seria:</p>
<pre><code class="language-c">int a[] = { 2, 4, 5, 6};

printf(&quot;%i\n&quot;, a[1]);     // 4

printf(&quot;%i\n&quot;, *(a+1) );  // 4
</code></pre>
<blockquote>
<p>Desta forma o valor de <code>a</code> n√£o ser√° alterado.</p>
</blockquote>
<p>Isso tamb√©m serve para atribuir valor aos itens de um array.</p>
<pre><code class="language-c">int a[] = { 2, 4, 5, 6};

a[1] = 90;

*(a+2) = 56
</code></pre>
<p>Notem que o √≠ndice ( o valor entre <code>[</code> e <code>]</code> ), √© somado a <code>a</code>, isso acontece porque um array cria uma fila de espa√ßos do mesmo tipo, uma do lado da outra, por isso <code>*(a+3)</code> √© o mesmo que <code>a[3]</code>.</p>
<h2 id="aloca√ß√£o-din√¢mica-arrays-din√¢micos"><a class="header" href="#aloca√ß√£o-din√¢mica-arrays-din√¢micos">Aloca√ß√£o din√¢mica (arrays din√¢micos)</a></h2>
<p>Em alguns casos, precisamos de mais espa√ßo do que a vari√°vel comum para guardar dados, e para esses casos geralmente usamos arrays, mas e se durante a execu√ß√£o eu necessite de um array maior... <em>‚Äú√â s√≥ criar um array maior e usar ele para a manipula√ß√£o do novos dados!‚Äù</em> ... Isso pode at√© funcionar, mas n√£o √© recomend√°vel, pois seria um desperd√≠cio de mem√≥ria.</p>
<p>Para resolver isso n√≥s podemos alocar a quantidade de mem√≥ria que queremos (em bytes) e usar um ponteiro com este endere√ßo de mem√≥ria, e se quisermos um espa√ßo maior, √© s√≥ realocar a mem√≥ria deste ponteiro, assim n√≥s poderemos aumentar e diminuir o tamanho do array.</p>
<blockquote>
<p>E como prometi no cap√≠tulo sobre strings... Esta √© a terceira forma de atribuir uma string:</p>
</blockquote>
<pre><code class="language-c">char * str;
str = &quot;string&quot;;
</code></pre>
<blockquote>
<p>Isto s√≥ funciona com strings, arrays de outros tipos tem que ser atribu√≠dos item a item.</p>
</blockquote>
<p>O pr√≥prio exemplo da atribui√ß√£o de uma string √© um exemplo de aloca√ß√£o din√¢mica, mas ela √© feita automaticamente:</p>
<pre><code class="language-c">char * str;          // aqui temos um ponteiro vazio.
str = &quot;coisa&quot;;       /* 
                        aqui n√≥s alocamos 6 bytes na mem√≥ria para
                        guardar { 'c', 'o', 'i', 's', 'a', '\0' }
                     */

printf(&quot;%s\n&quot;, str);

str = &quot;outra coisa&quot;; /*
                        aqui n√≥s realocamos o espa√ßo de 6 bytes
                        para 12 bytes e assim podemos guardar 
                        { 
                           'o', 'u', 't', 'r', 'a', ' ',
                           'c', 'o', 'i', 's', 'a'
                        }
                     */

printf(&quot;%s\n&quot;, str);
</code></pre>
<p>Se fossemos fazer o c√≥digo acima usando puramente ponteiros, n√≥s far√≠amos assim:</p>
<blockquote>
<p>Lembrando que ao alocar espa√ßos e referenciando com ponteiros, n√≥s estamos criando arrays.</p>
</blockquote>
<p>Antes de mais nada voc√™ tem que incluir o <code>stdlib.h</code> no seu arquivo (para evitar erros, sempre fa√ßa qualquer <code>include</code> no inicio do arquivo)</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;           // biblioteca necess√°ria para usar as fun√ß√µes de aloca√ß√£o.
</code></pre>
<blockquote>
<p>Para garantir inclua esta biblioteca em todos os exemplos a partir daqui.</p>
</blockquote>
<p>Agora sim, podemos continuar...</p>
<pre><code class="language-c">
char * str;                   // aqui temos um ponteiro vazio.

str = malloc (6);             // aqui n√≥s alocamos 6 bytes na mem√≥ria.

// guardando dados...
*( str + 0 ) = 'c';   // str[0] = 'c';
*( str + 1 ) = 'o';   // str[1] = 'o';
*( str + 2 ) = 'i';   // str[2] = 'i';
*( str + 3 ) = 's';   // str[3] = 's';
*( str + 4 ) = 'a';   // str[4] = 'a';
*( str + 5 ) = '\0';  // str[5] = '\0';

printf( str );
putchar('\n');

str = realloc (str, 12);        // aqui n√≥s realocamos o espa√ßo de 6 bytes para 12 bytes

// guardando dados...
str = &quot;outra coisa&quot;;
str[12] = '\0';

printf(&quot;%s\n&quot;, str);

free( str );           /*
                           essa linha vai no fim do programa e serve
                           para liberar a mem√≥ria que n√≥ alocamos,
                           para n√£o ocorrerem erros sempre temos
                           que liberar a mem√≥ria.
                       */

</code></pre>
<blockquote>
<p>Note que o ultimo printf est√° antes do <code>free</code>, pois se ele estiver depois, vai dar erro j√° que o espa√ßo alocado anteriormente seria apagado.</p>
</blockquote>
<p>A sa√≠da de ambos os c√≥digos √© a mesma:</p>
<pre><code>coisa
outra coisa
</code></pre>
<p><em>‚ÄúAh ent√£o eu vou sempre usar a primeira forma, porque √© mais f√°cil!‚Äù</em> , use, mas n√£o se esque√ßa que a primeira forma s√≥ funciona com strings, para outros tipos de arrays voc√™ ter√° que usar a segunda forma.</p>
<p>S√≥ para fixar melhor veja como funcionariam o array din√¢mico com o tipo <code>int</code>.</p>
<pre><code class="language-c">
// alocando a mem√≥ria que o array ter√°
int * array_dinamico = malloc ( sizeof (int) * 4); /*
                                                aqui n√≥s alocamos um espa√ßo que caiba 4 inteiros,
                                                pois o nosso array inicial ter√° 4 posi√ß√µes.
                                              */

array_dinamico [0] = 2;
*( array_dinamico + 1) = 3;
array_dinamico [2] = 23;
array_dinamico [3] = 894;

// realocando mem√≥ria para que caibam 5 posi√ß√µes
array_dinamico = realloc ( array_dinamico , sizeof (int) * 5);

array_dinamico [0] = 2;
*( array_dinamico + 1) = 3;
array_dinamico [2] = 23;
array_dinamico [3] = 894;
*( array_dinamico + 4) = 34;
</code></pre>
<blockquote>
<p>Lembre-se de alocar a quantidade certa de mem√≥ria para o ponteiro, ao contr√°rio dos arrays aqui voc√™ tem que saber a quantidade exata de bytes reservar, um macete muito √∫til √©:</p>
</blockquote>
<pre><code class="language-c">&lt;tipo&gt; * &lt;vari√°vel&gt; = malloc ( sizeof (&lt;tipo&gt;) * &lt;quantidade de posi√ß√µes&gt;);
</code></pre>
<blockquote>
<p>Desta forma a quantidade de bytes necess√°ria ser√° sempre respeitada.</p>
</blockquote>
<p>E de quebra vai a√≠ uma dica extra sobre arrays din√¢micos, eles podem ser atribu√≠dos diretamente, √© s√≥ colocar um <code>(&lt;tipo&gt; [])</code> antes do array que voc√™ quer atribuir:</p>
<blockquote>
<p>Mas cuidado, arrays normais n√£o aceitam isso, s√≥ use em arrays din√¢micos</p>
</blockquote>
<pre><code class="language-c">// Array normal
int a[3] = {0, 1, 2};
a = (int []){1, 2, 3};          // N√£o funciona!

// Array din√¢mico
int * ad = {0, 1, 2};
ad = (int []){1, 2, 3};         // Funciona!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="customiza√ß√£o-de-tipos"><a class="header" href="#customiza√ß√£o-de-tipos">Customiza√ß√£o de tipos</a></h1>
<p>At√© agora voc√™ s√≥ viu estruturas padr√µes do pr√≥prio C, e como us√°-las, mas agora voc√™ vai aprender a criar as suas pr√≥prias...</p>
<h2 id="structs-e-unions"><a class="header" href="#structs-e-unions">Structs e unions</a></h2>
<p><code>struct</code> √© o tipo de dado que cria uma estrutura pr√≥pria, e √© muito √∫til para criar ‚Äúobjetos‚Äù ou seja, criar vari√°veis com v√°rias caracter√≠sticas...</p>
<blockquote>
<p>E a galera que j√° conhece um pouco mais deve estar se perguntando ‚ÄúMas o C √© orientado a objetos?‚Äù e desde j√°, n√£o, o m√°ximo que voc√™ pode fazer no C √© criar um tipo com espa√ßos para armazenar dados, mas n√£o √© poss√≠vel criar objetos ou classes.</p>
</blockquote>
<pre><code class="language-c">
struct pessoa {
   char * nome;
   int idade;
   char sexo;
   float peso;
   float altura;
}

</code></pre>
<p>Como podem ver no exemplo acima, n√≥s criamos uma estrutura <code>pessoa</code> que pode receber um <code>nome</code>, uma <code>idade</code>, um <code>peso</code>, um <code>sexo</code> e uma <code>altura</code>, assim melhorando e muito nosso armazenamento de dados, <em>‚ÄúMas como eu posso acess√°-los?‚Äù</em>, muito simples:</p>
<pre><code class="language-c">struct pessoa joao;        // aqui n√≥s criamos uma pessoa &quot;joao&quot;.
joao.nome = &quot;Joao&quot;;        // aqui n√≥s atribu√≠mos &quot;Joao&quot; ao nome da pessoa.
</code></pre>
<p>E como voc√™ p√¥de notar agora existe um tipo <code>struct pessoa</code>, <em>‚ÄúMas, eu quero criar um tipo <code>pessoa</code>, √© poss√≠vel?‚Äù</em>, sim, √©, e para isso voc√™ vai usar o <code>typedef</code>, e ele serve para apelidar um tipo.</p>
<pre><code class="language-c">typedef int MyInt;

MyInt inteiro;
</code></pre>
<p>Mas como n√≥s queremos us√°-lo com a nossa <code>struct</code>, temos 3 formas de usar:</p>
<p>Criando o <code>struct</code> antes:</p>
<pre><code class="language-c">struct p { char * name };
typedef struct p pessoa;
</code></pre>
<p>Criando ao mesmo tempo:</p>
<pre><code class="language-c">typedef struct p { char * name } pessoa;
</code></pre>
<p>Criando ao mesmo tempo com uma <code>struct</code> an√¥nima:</p>
<pre><code class="language-c">typedef struct { char * name } pessoa;
</code></pre>
<p>E o resultado das senten√ßas anteriores √©:</p>
<pre><code class="language-c">pessoa joao;
joao.name = &quot;Joao&quot;;
</code></pre>
<blockquote>
<p>E para evitar erros de escopo, sempre declare structs fora do <code>main</code>.</p>
</blockquote>
<p>Outra estrutura muito interessante √© a <code>union</code>, ela √© semelhante a <code>struct</code>, mas a <code>union</code> assume apenas uma vari√°vel... <em>‚ÄúComo assim?‚Äù</em> ...observe:</p>
<pre><code class="language-c">// struct
{
   struct p {
      char * nome;
      int idade;
   };

   // Uso

   struct p joao;
   joao.nome = &quot;Joao&quot;;
   joao.idade = 12;
}

// union
{
   union p {
      char * nome;
      int idade;
   };

   // Uso

   union p joao;
   joao.nome = &quot;Joao&quot;;       // aqui voc√™ escolheu usar a vari√°vel nome
   puts(joao.idade);         /* aqui aqui ser√° imprimido &quot;Joao&quot;, j√° que
                                joao.idade est√° unido com joao.nome
                             */
    // Ou
    union p coisa;
    coisa.idade = 14;
    printf(&quot;%i\n&quot;, coisa.idade);
}
</code></pre>
<p>Um macete legal na atribu√≠√ß√£o de uma <code>struct</code> √© usar um array para isso, √© s√≥ colocar os valores na ordem de declara√ß√£o da struct, <em>‚ÄúQu√™?‚Äù</em>:</p>
<pre><code class="language-c">typedef struct {
    char * nome;
    int idade;
    float peso;
    float altura;
} pessoa;

//                      .nome, .idade, .peso, .altura
pessoa joao = (pessoa){&quot;joao&quot;,     13,  40.3,    1.60};
</code></pre>
<p>Ou caso voc√™ n√£o queira colocar na ordem √© s√≥ espec√≠ficar o atributo:</p>
<pre><code class="language-C">pessoa maria = (pessoa){
    .altura = 1.5
    .idade = 12,
    .nome = &quot;maria&quot;,
    .peso = 39.4,
};
</code></pre>
<p>E o mesmo vale para arrays de <code>struct</code>:</p>
<pre><code class="language-c">pessoa * pessoas = (pessoa []){
    (pessoa){ &quot;vanderlei&quot;, 25, 90, 1.80 },
    joao,
    (pessoa){
        .peso = 70,
        .altura = 1.90,
        .idade = 42,
        .nome = &quot;rita&quot;
    },
    maria
};
</code></pre>
<h2 id="enum"><a class="header" href="#enum">Enum</a></h2>
<p>O <code>enum</code> vem enumera√ß√£o e nesse voc√™ deseje designar valores constantes para as suas estruturas.</p>
<pre><code class="language-c">typedef enum {
   true = 1,
   false = 0,
} bool;

bool falso = false;
</code></pre>
<blockquote>
<p>S√≥ pode colocar inteiros em enums.</p>
</blockquote>
<p>E acima acabamos de criar o tipo booleano no C.</p>
<p>Como s√≥ √© poss√≠vel colocar inteiros em enums, e por isso existe um macete legal para atribuir esses n√∫meros:</p>
<pre><code class="language-c">typedef enum {

   zero = 0,        // zero √© 0
   um,              // um √© zero + 1
   dois,            // dois √© um + 1
   tres,            // tres √© dois + 1

   sete = 7,        // sete √© 7
   oito,            // oito √© sete + 1
   nove,            // nove √© oito + 1

   quatro = 4,      // quatro √© 4
   cinco,           // cinco √© quatro + 1
   seis             // seis √© seis + 1

} por_extenso;
</code></pre>
<pre><code class="language-c">por_extenso numero = dois;

printf(&quot;%i\n&quot;, numero)
printf(&quot;%i\n&quot;, dois)
</code></pre>
<blockquote>
<p>Sa√≠da:</p>
</blockquote>
<pre><code class="language-c">2
2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hacks-e-extras"><a class="header" href="#hacks-e-extras">Hacks e Extras</a></h1>
<h2 id="comandos-do-pr√©-processador"><a class="header" href="#comandos-do-pr√©-processador">Comandos do pr√©-processador</a></h2>
<p>O pr√©-processador √© a ferramenta que prepara o c√≥digo para a compila√ß√£o, por isso existem ele tem seus pr√≥prios comandos, e caso voc√™ queira curiar a vers√£o preprocessada de um arquivo em C use o comando <code>gcc -E &lt;arquivo&gt; &gt; &lt;saida.c&gt;</code></p>
<p>Basicamente todos os comandos do pr√©-processador come√ßam com <code>#</code>, e um desses comandos √© o pr√≥prio <code>#include</code>, que usamos para importar nossas bibliotecas, que al√©m de importar bibliotecas padr√µes, voc√™ pode importar seus pr√≥prios arquivos.</p>
<pre><code class="language-c">#include &quot;minhas_funcoes.c&quot;
#include &quot;/home/robocopgay/biblioteca.c&quot;
</code></pre>
<blockquote>
<p>Quando voc√™ usa as aspas duplas (<code>&quot;</code>) voc√™ pode passar o caminho para a sua biblioteca (caso ela esteja no mesmo diret√≥rio coloque apenas o nome do arquivo)</p>
</blockquote>
<p>Outra diretris interessante √© o <code>#declare</code>, que serve para criar constantes e macros:</p>
<pre><code>#define PI 3.14
#define soma (n, n2) n + n2

#define add_item ( array, item )\
array = realloc( sizeof (array) + sizeof (item) );
</code></pre>
<blockquote>
<p>Note que na ultima linha da ultima macro foi usado o <code>\</code> para indicar que a pr√≥xima linha pertence a ela.</p>
</blockquote>
<p>A vantagem aqui √© que se precisa de uma constante, √© mais √∫til usar o <code>#define</code> que criar uma vari√°vel, pois a vari√°vel tem que ocupar um espa√ßo na mem√≥ria, enquanto o pre-processador apenas substitue o lugar onde a macro ou constante √© chamada pelo seu conte√∫do.</p>
<p>E a diretris <code>#undef</code> <em>‚Äúdesdefine‚Äù</em> uma macro ou constante</p>
<pre><code class="language-c">#define max 10

int i = max*3;

#undef max
define max 30
</code></pre>
<p>E existe o <code>#if</code>, <code>#else</code>, <code>#elif</code> e o <code>#endif</code>, usados para condicional</p>
<pre><code class="language-c">#define MIN_SIZE 2

#if defined(MAX_SIZE)          // if -&gt; se
    #define tamanho MAX_SIZE
#elif MIN_SIZE &gt; 2             // else if -&gt; sen√£o se
    #define tamanho 2
#else                          // else -&gt; sen√£o
    #define tamanho MIN_SIZE+1
#endif                         // end -&gt; fim

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main (int argc, char ** argv){
    printf(&quot;%i&quot;, tamanho);
return 0;
}
</code></pre>
<p>Al√©m desses existem os atalhos espec√≠ficos para o <code>#if defined(&lt;macro&gt;)</code> e o <code>#if !defined(&lt;macro&gt;)</code>:</p>
<pre><code class="language-C">#define MAX_SIZE 35

#ifdef MAX_SIZE
    #define TAMANHO_MAXIMO MAX_SIZE
#endif

#ifndef MIN_SIZE
    #define TAMANHO_MINIMO 0
#endif
</code></pre>
<p>Outra coisa interessant√≠ssima √© criar strings a partir de c√≥digo, <em>‚ÄúU√©? n√£o entendi...‚Äù</em>, muito simples... Quando usamos o operador <code>#</code> dentro de uma macro ele transforma o comando em string</p>
<pre><code class="language-c">#define to_str(texto) #texto

puts( to_str(Hello mundo!!) );
</code></pre>
<blockquote>
<p>Sa√≠da:</p>
</blockquote>
<pre><code>Hello mundo!!
</code></pre>
<p>Ou se quiser juntar duas informa√ß√µes use o <code>##</code></p>
<pre><code class="language-c">#define to_str(texto) #texto
#define str_function_template(func) str##func

int l = str_function_template(len)(&quot;abacate&quot;);
printf(&quot;\&quot;%s\&quot; tem %i letras.\n&quot;, &quot;abacate&quot;, l);
</code></pre>
<blockquote>
<p>Sa√≠da:</p>
</blockquote>
<pre><code>&quot;abacate&quot; tem 7 letras.
</code></pre>
<h2 id="chegou-a-hora-de-praticar-de-novo"><a class="header" href="#chegou-a-hora-de-praticar-de-novo">Chegou a hora de praticar de novo!</a></h2>
<h3 id="desafio-5"><a class="header" href="#desafio-5">Desafio 5</a></h3>
<p>Fa√ßa uma calculadora onde o usu√°rio digite dois n√∫meros (reais) e no final ele pergunte qual opera√ß√£o matem√°tica fazer ( +, -, / ou * ) e no fim ele pergunte se a pessoa deseja calcular de novo.</p>
<blockquote>
<p>Sa√≠da:</p>
</blockquote>
<pre><code>Digite 2 n√∫meros: 2 3
Voc√™ quer somar (+), subtrair (-), multiplicar (*) ou dividir (/)?
 +
2 + 3 = 5

Deseja calcular de novo? [S/n] n
</code></pre>
<h4 id="resposta-3"><a class="header" href="#resposta-3">Resposta</a></h4>
<p>Primeiramente iremos declarar as vari√°veis necess√°rias:</p>
<pre><code class="language-c">int n1, n2;    // n√∫meros que iremos ler
char operacao; // opera√ß√£o
int res;       // resposta
</code></pre>
<p>E iremos ler os dados necess√°rios:</p>
<pre><code class="language-c">printf(&quot;Digite 2 n√∫meros: &quot;);
scanf(&quot;%i %i&quot;, &amp;n1, &amp;n2);

printf(&quot;Voc√™ quer somar (+), subtrair (-), multiplicar (*) ou dividir (/)? &quot;);
operacao = getchar();
</code></pre>
<p>Agora n√≥s vamos efetuar os devidos c√°lculos:</p>
<pre><code class="language-c">if (operacao == '+')
   res = n1 + n2;

else if (operacao == '-')
   res = n1 - n2;

else if (opera√ß√£o == '/')
   res = n1 / n2;

else res = n1 * n2;
</code></pre>
<p>E exibimos o resultado:</p>
<pre><code class="language-c">printf(&quot;\n%i %c %i = %i\n&quot;, n1, operacao, n2, res);
</code></pre>
<p>E se voc√™ √© atento notou que faltou perguntar se a pessoa que calcular de novo, mas antes de fazer esta pergunta n√≥ temos que colocar o c√≥digo que queremos repetir dentro de uma estrutura de repeti√ß√£o, mas n√£o coloque a parte da declara√ß√£o de vari√°veis:</p>
<pre><code class="language-c">do {

   printf(&quot;Digite 2 n√∫meros: &quot;);
   scanf(&quot;%i %i&quot;, &amp;n1, &amp;n2);

   printf(&quot;Voc√™ quer somar (+), subtrair (-), multiplicar (*) ou dividir (/)? &quot;);
   operacao = getchar();

   if (operacao == '+')
      res = n1 + n2;
   else if (operacao == '-')
      res = n1 - n2;
   else if (opera√ß√£o == '/')
      res = n1 / n2;
   else res = n1 * n2;

   printf(&quot;\n%i %c %i = %i\n&quot;, n1, operacao, n2, res);

   printf(&quot;Deseja calcular de novo? [S/n] &quot;);

   if ( getchar() == 'n' )
      break;

} while ( 1 );
</code></pre>
<blockquote>
<p>Eu escolhi o <code>do..while</code> porque o c√≥digo sempre vai ser executado pelo menos uma vez.</p>
</blockquote>
<p>E o c√≥digo final ficou assim:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char *argv[])
{
  int n1, n2;    // n√∫meros que iremos ler
  char operacao; // opera√ß√£o
  int res;       // resposta

  do {

    // lendo dados
    printf(&quot;Digite 2 n√∫meros: &quot;);
    scanf(&quot;%i %i&quot;, &amp;n1, &amp;n2);

    printf(&quot;Voc√™ quer somar (+), subtrair (-), multiplicar (*) ou dividir (/)? &quot;);
    scanf(&quot;%c %c&quot;, &amp;operacao, &amp;operacao);

    // processando dados
    if (operacao == '+')
      res = n1 + n2;
    else if (operacao == '-')
      res = n1 - n2;
    else if (operacao == '/')
      res = n1 / n2;
    else res = n1 * n2;

    // exibindo dados
    printf(&quot;\n%i %c %i = %i\n&quot;, n1, operacao, n2, res);

    // reiniciando ou interrompendo programa
    printf(&quot;Deseja calcular de novo? [S/n] &quot;);
    getchar();
    if ( getchar() == 'n' )
      break;

  } while ( 1 );
  return 0;
}
</code></pre>
<h3 id="desafio-6"><a class="header" href="#desafio-6">Desafio 6</a></h3>
<p>Fa√ßa um programa que leia 5 n√∫meros e retorne a soma entre os 3 menores divididos pelo maior.</p>
<blockquote>
<p>Sa√≠da:</p>
</blockquote>
<pre><code>digite 5 numeros: 10 36 88 89 43

(10+36+43)/89 = 1.0
</code></pre>
<h4 id="resposta-4"><a class="header" href="#resposta-4">Resposta</a></h4>
<p>Primeiramente precisamos ler os dados</p>
<pre><code class="language-c">int n[5];
printf(&quot;digite 5 numeros: &quot;);
scanf(&quot;%i%i%i%i%i&quot;, &amp;n[0], &amp;n[1], &amp;n[2], &amp;n[3], &amp;n[4]);
</code></pre>
<p>Agora vamos pegar o maior n√∫mero digitado (j√° que √© mais simples que pegar os 3 menores).</p>
<pre><code class="language-c">int maior = 0;
for (int i=0; i&lt;5; i++){
  maior = (n[i] &gt; n[maior])?i:maior;
}
</code></pre>
<p>Agora a parte mais complidada, existem duas formas de fazer isso, a primeira √© comparar manualmente e atribuir a vari√°veis.</p>
<pre><code class="language-c">int menor1 = maior, menor2 = maior, menor3 = maior;
maior = n[maior];
</code></pre>
<blockquote>
<p>temos que dar o <code>maior</code> como valor, porque para comparar temos que ter certeza de que pode existir um valor menor, caso atribuamos o <code>0</code> a vari√°vel sempre vai ter o menor valor</p>
</blockquote>
<pre><code class="language-c">for (int i=0; i++; i&lt;5){
  if (n[i] &lt; n[menor1])
    menor1 = n[i];
maior = n[maior]
}

for (int i=0; i++; i&lt;5){
  if (n[i] &lt; n[menor2] &amp;&amp; i != menor1)
    menor1 = n[i];
}

for (int i=0; i++; i&lt;5){
  if (n[i] &lt; n[menor3] &amp;&amp; i != menor2 &amp;&amp; i != menor1)
    menor1 = n[i];
}
</code></pre>
<p>Essa forma com certeza funciona, mas existe uma forma mais inteligente de fazer:</p>
<pre><code>maior = n[maior];
int menores [] = {maior, maior, maior};
for (int j=0; j&lt;3; j++){
  for (int i=0; i&lt;5; i++){
    if (n[i]&lt;menores[j]){

      menores[j] = n[i];
      n[i] = maior;

    }
  }
}
</code></pre>
<p>E por fim vamos exibir os resultados:</p>
<pre><code class="language-c">printf(&quot;(%i+%i+%i)/%i = %1.1f\n&quot;,
    menores[0],
    menores[1],
    menores[2],
    maior,
    (float)(menores[0]+menores[1]+menores[2])/maior
    );
</code></pre>
<blockquote>
<p>C√≥digo final:</p>
</blockquote>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char *argv[])
{

  // criando e lendo dados
  int n[5];
  printf(&quot;digite 5 numeros: &quot;);
  scanf(&quot;%i%i%i%i%i&quot;, &amp;n[0], &amp;n[1], &amp;n[2], &amp;n[3], &amp;n[4]);

  // pegando o maior valor
  int maior = 0;
  for (int i=0; i&lt;5; i++)
    maior = (n[i] &gt; n[maior])?i:maior;

  // pegando os menores valores
  maior = n[maior];
  int menores [] = {maior, maior, maior};
  for (int j=0; j&lt;3; j++){
    for (int i=0; i&lt;5; i++){

      // caso o numero atual for menor que o menor
      if (n[i]&lt;menores[j]){
        menores[j] = n[i];

        /* o numero atual √© o menor de todos
         * e por isso tem que deixar de ser,
         * ou n√£o haver√° como pegar o segundo
         * menor e muito menos o terceiro j√°
         * que ele seria o menor.
         */
        n[i] = maior;
      }

    }

  }

  printf(&quot;(%i+%i+%i)/%i = %1.1f\n&quot;,
      menores[0],
      menores[1],
      menores[2],
      maior,
      (float)(menores[0]+menores[1]+menores[2])/maior
      );

  return 0;
}

</code></pre>
<h3 id="desafio-7"><a class="header" href="#desafio-7">Desafio 7</a></h3>
<p>Fa√ßa um algoritmo que leia n√∫meros inteiros indefinidamente e s√≥ pare quando o valor lido for maior que 1000, nos resultados devem ser informados o maior, o menor, e a media entre eles, al√©m de dizer quais foram repetidos e se repetidos o n√∫mero de vezes que foi repetido, al√©m de todos os n√∫meros primos da lista.</p>
<pre><code>digitte n√∫meros... (para parar digite um numero &gt;= 1000)
9
8
4
2
9
8
11
390
23
42
13
1000
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world-grafico"><a class="header" href="#hello-world-grafico">Hello World Grafico</a></h1>
<p>Geralmente na internet em geral, a maioria dos projetos feitos em C usa uma ferramenta para automatizar a compila√ß√£o, vou demonstar aqui com o <code>make</code>, mas alguns projetos usam outras ferramentas (geralmente todos tem um <code>README</code> para auxiliar na compila√ß√£o).</p>
<p>O ‚Äúmini projeto‚Äù que vamos escrever √© um ‚Äúhello mundo‚Äù gr√°fico, usando gtk, eu preferi fazer um gr√°fico para exemplificar o uso de bibliotecas externas e para dar um gostinho da programa√ß√£o GUI para voc√™s...</p>
<blockquote>
<p>hello.h: header com os prot√≥tipos de fun√ß√µes</p>
</blockquote>
<pre><code class="language-c">#include &lt;gtk/gtk.h&gt;
#include &lt;string.h&gt;

// Lista de texto que vai aparecer na tela
typedef struct lista lista;
struct lista {
    char *texto;
    lista *prox;
};

// Fun√ß√£o que troca o texto na interface
void mudar_rotulo(GtkWidget *, char *);

// Fun√ß√£o que organiza a lista de textos
void organize_lista(lista *, int tamanho);
</code></pre>
<p>Basicamente o header (ou cabe√ßalhio) acima serve para declarar as fun√ß√µes e estruturas da nossa biblioteca.</p>
<blockquote>
<p>hello.c: biblioteca com as fun√ß√µes usadas pelo programa</p>
</blockquote>
<pre><code class="language-c">#include &quot;hello.h&quot;

void
mudar_rotulo(GtkWidget * rotulo, char * texto){
    g_print (&quot;hello: &quot;);
    g_print (texto);
    g_print (&quot;\n&quot;);

    // Mudando o texto do &quot;rotulo&quot;
    gtk_label_set_text(GTK_LABEL(rotulo), texto);
}

void
organize_lista(lista * lista_de_textos, int len){
    // Organizando o acesso aos posteriores
    for (int i = 0; i&lt;len; i++){
        lista_de_textos[i].prox = &amp;lista_de_textos[i+1];
        lista_de_textos[i].prox = &amp;lista_de_textos[i+1];
    }
    lista_de_textos[len-1].prox = &amp;lista_de_textos[0];
}
</code></pre>
<blockquote>
<p>main.c: O nosso programa</p>
</blockquote>
<pre><code class="language-c">#include &quot;hello.h&quot;

GtkWidget *janela;
GtkWidget *conteiner;

GtkWidget *botao;
GtkWidget *rotulo;

lista * lista_de_textos;

void
hello (void){
    // Muando o texto do rotulo
    mudar_rotulo(rotulo, lista_de_textos-&gt;texto);

    // Mudando o texto atual para o proximo da lista
    lista_de_textos = lista_de_textos-&gt;prox;
}


int
main (int argc, char *argv[]){

    // criando a lista de textos
    lista_de_textos = (lista []){
     {.texto = &quot;Hello mundo!!&quot;, NULL},              // 1
     {.texto = &quot;Eu amo C!!&quot;, NULL},                 // 2
     {.texto = &quot;C para seres humanos!&quot;, NULL},      // 3
     {.texto = &quot;Outra coisa aleat√≥ria!&quot;, NULL},     // 4
     {.texto = &quot;Acesse robocopgay.github.io&quot;, NULL} // 5
    };
    organize_lista(lista_de_textos, 5);

    // inicializando configura√ß√µes padr√µes da biblioteca
    gtk_init (&amp;argc, &amp;argv);

    // criando a janela principal
    janela = gtk_window_new (GTK_WINDOW_TOPLEVEL);
    // quando o usu√°rio fechar a janela, ela ser√° fechada
    gtk_signal_connect (GTK_OBJECT (janela), &quot;destroy&quot;,
            GTK_SIGNAL_FUNC (gtk_main_quit), NULL);

    // criando um r√≥tulo com o texto &quot;...&quot;
    rotulo = gtk_label_new(&quot;...&quot;);
    // criando um bot√£o com o texto &quot;Clique em mim&quot;
    botao = gtk_button_new_with_label (&quot;Clique em mim&quot;);

    // criando um conteiner para guardar os componentes acima (rotulo, botao)
    conteiner = gtk_vbox_new((gint *)5,(gint *)5);

    // quando o usu√°rio clicar no bot√£o ele vai chamar a fun√ß√£o hello
    gtk_signal_connect (GTK_OBJECT (botao), &quot;clicked&quot;,
            GTK_SIGNAL_FUNC (hello), NULL);

    // adicionando componentes ao conteiner
    gtk_container_add(GTK_BOX(conteiner), rotulo);
    gtk_container_add(GTK_BOX(conteiner), botao);

    // adicionando o conteiner √† janela
    gtk_container_add (GTK_CONTAINER (janela), conteiner);

    // tornando os componentes vis√≠veis
    gtk_widget_show_all (janela);

    // iniciando a execu√ß√£o do aplicativo gr√°fico
    gtk_main();
    return 0;
}
</code></pre>
<p>N√£o se preocupe em entender a parte de interface gr√°fica, eu coloquei mais por que se voc√™ for compilar a aplica√ß√£o acima com os comandos de sempre (<code>gcc main.c -o hello</code>), o programa acima n√£o ir√° compilar, isso acontece porque o GTK+ (A biblioteca de interface gr√°fica utilizada pelo programa) √© uma biblioteca externa, e n√£o est√° dispon√≠vel por padr√£o no seu computador.</p>
<p>E para consertar esse problema, primeiro temos que baixar o GTK:</p>
<blockquote>
<p>E me desculpem galera de Windows, mas eu n√£o sei como usar GTK no sistema de voc√™s, fiz diversas pesquisas a respeito e tentei instalar e usar, mas n√£o consegui, ent√£o est√£o por conta pr√≥pria para tentar compilar.</p>
</blockquote>
<h2 id="macosx"><a class="header" href="#macosx">MacOSX</a></h2>
<pre><code class="language-sh">$ brew install gtk+
</code></pre>
<h2 id="debian-2"><a class="header" href="#debian-2">Debian</a></h2>
<pre><code class="language-sh">$ sudo apt install libgtk-2-dev
</code></pre>
<h2 id="red-hat-2"><a class="header" href="#red-hat-2">Red Hat</a></h2>
<pre><code class="language-sh">$ sudo dnf install gtk2-devel
</code></pre>
<h2 id="arch-linux-2"><a class="header" href="#arch-linux-2">Arch Linux</a></h2>
<pre><code class="language-sh">$ sudo pacman -S gtk2
</code></pre>
<h2 id="compilando"><a class="header" href="#compilando">Compilando</a></h2>
<p>E para compilar n√≥s usar√≠amos:</p>
<pre><code class="language-bash">$ gcc -o hello-gtk hello.c main.c $(pkg-config --libs --cflags gtk+-2.0)
</code></pre>
<p>Isso geraria um binario <code>hello-gtk</code>, e para automatizar isso:</p>
<blockquote>
<p>Makefile: arquivo de compila√ß√£o</p>
</blockquote>
<pre><code class="language-Makefile">CC=gcc
LIBS=$(pkg-config --libs gtk+-2.0)
CFLAGS=$(pkg-config --cflags gtk+-2.0)

all: hello-gtk

hello-gtk:
    @echo CC -o $@ hello.c main.c LIBS CFLAGS
    ${CC} -o $@ hello.c main.c ${LIBS} ${CFLAGs}
</code></pre>
<p>E agora para compilar √© s√≥ digitar <code>make</code> dentro do diret√≥rio do projeto.</p>
<p>Outra coisa interessante do make √© dar op√ß√µes para ele como:</p>
<pre><code>install:
    @cp hello-gtk /usr/bin/ -v
clean:
    @rm hello-gtk
opcao-aleatoria:
    @echo opcao aleatoria
</code></pre>
<p>E √© s√≥ adicionar a op√ß√£o na execu√ß√£o do make:</p>
<pre><code>$ make opcao-aleatoria
opcao aleatoria
</code></pre>
<p>Outra solu√ß√£o √© colocar algumas configura√ß√µes em um arquivo separado, que geralmente √© chamado de config.mk (mas isso √© opcional):</p>
<blockquote>
<p>config.mk:</p>
</blockquote>
<pre><code class="language-Makefile">VERSION=&quot;0.1&quot;
CC=gcc
LIBS=$(pkg-config --libs gtk+-2.0)
CFLAGS=$(pkg-config --cflags gtk+-2.0)
</code></pre>
<blockquote>
<p>Makefile:</p>
</blockquote>
<pre><code class="language-Makefile">all:
    ${CC} -o hello-${VERSION} hello.c main.c ${LIBS} ${CFLAGS}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bibliotecas-√öteis"><a class="header" href="#bibliotecas-√öteis">Bibliotecas √öteis</a></h1>
<p>At√© agora s√≥ usamos duas bibliotecas em nossos porgramas em C, e n√£o vimos nem 10% dessas, ent√£o para deixar seu conhecimento mais completo aqui vamos mostrar algumas fun√ß√µes dessas duas bibliotecas, al√©m de outras que tamb√©m podem ser bem interessantes.</p>
<h2 id="stdioh"><a class="header" href="#stdioh">stdio.h</a></h2>
<pre><code class="language-c">#include &lt;stdio.h&gt;
</code></pre>
<p>Como j√° vimos as fun√ß√µes <code>scanf</code>, <code>printf</code>, <code>putchar</code>, <code>puts</code>, <code>getchar</code>, <code>gets</code>, <code>fprintf</code> e <code>fgets</code>, iremos ignor√°-las.</p>
<p>O <code>std</code> significa exclusivamente ‚Äústandard‚Äù (‚Äùpadr√£o‚Äù em portugu√™s), <code>i</code> √© de ‚Äúinput‚Äù (entrada) e o <code>o</code> de ‚Äúoutput‚Äù (sa√≠da), portanto entrada e sa√≠da de dados padr√£o.</p>
<h3 id="io-em-arquivos"><a class="header" href="#io-em-arquivos">I/O em arquivos</a></h3>
<p>Como o <code>stdio</code> serve para entrada e sa√≠da de dados, √≥bviamente tamb√©m √© usada para manipula√ß√£o de arquivos, usada tanto para ler (input), quanto para escrever (output) neles.</p>
<p>Para ler um arquivo precisamos criar um ponteiro do tipo <code>FILE</code></p>
<pre><code class="language-c">FILE * arquivo;
</code></pre>
<h4 id="leitura"><a class="header" href="#leitura">Leitura</a></h4>
<blockquote>
<p>crie um arquivo <code>j.txt</code> com ‚Äújoao‚Äù escrito dentro</p>
</blockquote>
<p>Para abrir o arquivo <code>j.txt</code> no nosso programa, √© s√≥ usar a fun√ß√£o <code>fopen</code>.</p>
<pre><code class="language-c">arquivo = fopen(&quot;j.txt&quot;, &quot;r&quot;);
</code></pre>
<blockquote>
<p>O <code>&quot;r&quot;</code> no segundo parametro √© o modo desse arquivo, nesse caso, abrimos um arquivo em modo leitura.</p>
</blockquote>
<p>Para ler e exibir o que foi lido √© s√≥ usar o <code>fgetc</code>:</p>
<pre><code class="language-c">char caractere = fgetc(arquivo);
</code></pre>
<blockquote>
<p>O <code>fgetc</code> retorna um caractere de cada vez, e quando le o caractere, quando voc√™ for ler de novo ele ler√° somente o pr√≥ximo, exemplo:</p>
</blockquote>
<pre><code class="language-c">// suponha que o arquivo &quot;texto.txt&quot; tem &quot;abc&quot; escrito dentro
FILE *f = fopen(&quot;texto.txt&quot;, &quot;r&quot;);
char a, b, c;

b = fgetc(f); // -&gt; &quot;a&quot;
c = fgetc(f); // -&gt; &quot;b&quot;
a = fgetc(f); // -&gt; &quot;c&quot;

print(&quot;%c %c %c\n&quot;, a, b, c);
</code></pre>
<blockquote>
<p>Sa√≠da:</p>
</blockquote>
<pre><code>c a b
</code></pre>
<p>Lembre-se que o fim de um arquivo √© demarcado por uma constante chamada de <code>EOF</code> (significa ‚Äúend of file‚Äù ou ‚Äúfim do arquivo‚Äù), logo, se voce usar um loop, para ler o tal arquivo, usem o <code>EOF</code> como ‚Äúflag‚Äù</p>
<blockquote>
<p>‚Äúflag‚Äù √© a condi√ß√£o de interrup√ß√£o</p>
</blockquote>
<pre><code class="language-c">char caractere;
do {
  caractere = fgetc(arquivo); // -&gt; &lt;caractere&gt; = fgetc(&lt;arquivo&gt;)
  putchar(caractere);
} while (caractere != EOF);
</code></pre>
<p>E depois de terminar de usar, assim como voc√™ tem que liberar a mem√≥ria com o <code>free</code> trabalhando com ponteiros, voc√™ tem que fechar o arquivo, ou ele vai ficar ocupando mem√≥ria √† toa</p>
<pre><code class="language-c">fclose(arquivo);
</code></pre>
<p>E ficaria assim:</p>
<pre><code class="language-c">FILE * arquivo;
arquivo = fopen(&quot;j.txt&quot;, &quot;r&quot;);

char caractere;
do {
  caractere = fgetc(arquivo);
  putchar(caractere);
} while (caractere != EOF);
fclose(arquivo);
</code></pre>
<p>Na minha humilde opni√£o √© muito melhor ler os dados caractere por caractere porque assim se tem mais controle dos dados, mas existem outras fun√ß√µes que auxiliam nisso.</p>
<p>O <code>fscanf</code> l√™ dados do arquivo e joga na vari√°vel estipulada:</p>
<pre><code class="language-c">FILE *arquivo = fopen(&quot;texto.txt&quot;, &quot;r&quot;);

char * texto_do_arquivo = malloc(10);
fscanf(arquivo, &quot;%s&quot;, texto_do_arquivo);

printf (&quot;%s&quot;, texto_do_arquivo);

fclose(arquivo);
free(texto_do_arquivo);
</code></pre>
<blockquote>
<p>N√£o usei a forma de array aqui porque aparentemente o <code>fscanf</code> crachou comigo, mas sinta-se a vontade para testar se isso acontece com voc√™ tamb√©m...</p>
</blockquote>
<p>O <code>fscanf</code> vai ler at√© o primeiro espa√ßo ou a primeira quebra de linha (<code>\n</code>).</p>
<p>Tamb√©m d√° pra fazer com o j√° conhecido <code>fgets</code>:</p>
<pre><code class="language-c">FILE *f = fopen(&quot;f.txt&quot;, &quot;r&quot;);

char str [100];
fgets (f, 100, str); // -&gt; fgets ( &lt;arquivo&gt;, &lt;tamanho da string&gt;, &lt;string&gt; )

fclose(f);
</code></pre>
<p>E por fim com o <code>fread</code>, que √© uma forma mais direta de ler os dados, mas para usar o <code>fread</code> voc√™ tem que saber o limite da leitura ( que no nosso caso √© o fim do arquivo), e para descobrir isso, n√≥s vamos usar duas fun√ß√µes chamadas <code>fseek</code> e <code>ftell</code>.</p>
<pre><code class="language-c">fseek(arquivo, 0, SEEK_END); // mudando o &quot;cursor&quot; para o fim do arquivo
size_t tamanho_arquivo = ftell(arquivo); // pegando a posi√ß√£o do cursor
fseek(arquivo, 0, SEEK_SET); // colocando o cursor no inicio de novo
</code></pre>
<p>Feito isso √© s√≥ ler usando o <code>fread</code></p>
<pre><code class="language-c">fread(      texto,        sizeof (char),              tamanho_arquivo, arquivo );
//   ( &lt;ponteiro&gt;, &lt;tmh do tipo do ptr&gt;, &lt;limite da leitura em bytes&gt;, &lt;arquivo&gt; )
</code></pre>
<p>E vai ficar assim:</p>
<pre><code class="language-c">FILE *arquivo = fopen(&quot;f.txt&quot;, &quot;r&quot;);

fseek(arquivo, 0, SEEK_END); // mudando o &quot;cursor&quot; para o fim do arquivo
size_t tamanho_arquivo = ftell(arquivo); // pegando a posi√ß√£o do cursor
fseek(arquivo, 0, SEEK_SET); // colocando o cursor no inicio de novo

char * texto = malloc( tamanho_arquivo );

fread( texto, sizeof (char), tamanho_arquivo, arquivo );

free(texto);
fclose(arquivo);
</code></pre>
<blockquote>
<p>O conte√∫do do arquivo vai ser escrito na vari√°vel <code>texto</code></p>
</blockquote>
<h4 id="escrita"><a class="header" href="#escrita">Escrita</a></h4>
<p>Para abrir um arquivo em modo escrita ao inv√©s de colocar o <code>r</code> no parametro do <code>fopen</code>, colocamos um <code>w</code>:</p>
<pre><code class="language-c">FILE *arquivo = fopen(&quot;texto.txt&quot;, &quot;w&quot;);
</code></pre>
<blockquote>
<p>Nesse caso, se o arquivo n√£o existir, ele ser√° criado, mas se existir um arquivo ele perder√° todos os seus dados.</p>
</blockquote>
<p>Para escrever um <code>char</code> em um arquivo usamos a fun√ß√£o <code>fputc</code></p>
<pre><code class="language-c">fputc('a', arquivo); // -&gt; fputc( &lt;char&gt;, &lt;arquivo&gt; )
</code></pre>
<p>Para escrever uma string use o <code>fputs</code></p>
<pre><code class="language-c">fputs(&quot;string com coisas&quot;, arquivo); // -&gt; fputs(&lt;string&gt;, &lt;arquivo&gt;)
</code></pre>
<p>Ou se quiser escrever um dados formatado use o j√° estudado <code>fprintf</code></p>
<pre><code class="language-c">fprintf ( arquivo, &quot;%i &gt; %i = %s&quot;, 4, 3, (4 &gt; 3? &quot;True&quot;: &quot;False&quot;));
</code></pre>
<p>E por fim voc√™ pode usar o irm√£o do <code>fread</code>, o <code>fwrite</code>:</p>
<pre><code class="language-c">char texto [] = &quot;texto aleatorio para colocar no arquivo&quot;;
fwrite( texto, sizeof (char), sizeof(texto), arquivo );
</code></pre>
<p>Mas esses n√£o s√£o os √∫nicos modos de abertura de um arquivo</p>
<pre><code class="language-c">&quot;r&quot;  // -&gt; read: somente leitura
&quot;w&quot;  // -&gt; write: somente escrita, mas apaga o conte√∫do do arquivo antes de escrever
&quot;a&quot;  // -&gt; append: somente escrita
&quot;r+&quot; // -&gt; read/write: leitura e escrita
&quot;w+&quot; // -&gt; read/write: leitura e escrita, mas apaga o conte√∫do do arquivo antes de escrever
&quot;a+&quot; // -&gt; read/append: leitura e escrita
</code></pre>
<blockquote>
<p>Fa√ßa seus testes com cada um deles, para ver funcionando na pr√°tica</p>
</blockquote>
<p>Voc√™ j√° deve ter percebido que as mesmas fun√ß√µes que usamos em arquivos, s√£o usadas na <code>stdout</code>, <code>stdin</code> e <code>stderr</code>, n√£o √© mesmo?
Isuuso acontece, porque essas 3 vari√°veis s√£o arquivos, e por esse motivo voc√™ pode usar todas as fun√ß√µes usadas em arquivos colocando elas no lugar, mas lembre-se, o <code>stdout</code> e o <code>stderr</code> est√£o em modo <code>&quot;w&quot;</code>, enquanto o <code>stdin</code> est√° em modo <code>&quot;r&quot;</code>, portanto, voc√™ s√≥ pode escrever no <code>stdout</code> e no <code>stderr</code>, e s√≥ pode ler o <code>stdin</code>. Divirta-se!</p>
<h3 id="posicionamento-em-arquivos"><a class="header" href="#posicionamento-em-arquivos">Posicionamento em arquivos</a></h3>
<p>Para ‚Äúfinalizar‚Äù este assunto, existem algumas fun√ß√µes que podem ser √∫teis na manipula√ß√£o de arquivos, como o <code>fseek</code> (que j√° foi visto de maneira superficial)</p>
<blockquote>
<p>N√£o vamos finalizar totalmente porque ainda faltam algumas fun√ß√µes, que agente vai ver no cap√≠tulo de <code>stdarg.h</code></p>
</blockquote>
<pre><code class="language-c">FILE *j = fopen(&quot;j.txt&quot;, &quot;r&quot;);

fseek( j, 0, SEEK_SET); // passa o cursor para o inicio do arquivo
fseek( j, 0, SEEK_CUR); /* passa o cursor para a posi√ß√£o atual do ponteiro
                           se ja tiver lido 3 caracteres, o cursor volta para
                           o caractere 3
                        */
fseek( j, 0, SEEK_END);
</code></pre>
<p>Caso queira retornar para o inicio do arquivo, voc√™ pode usar a vers√£o simplificada do <code>fseek</code> que se chama <code>rewind</code></p>
<pre><code class="language-c">FILE * arquivo = open(&quot;j.txt&quot;, &quot;r&quot;);
rewind( arquivo );
</code></pre>
<p>A fun√ß√£o <code>ftell</code>, tamb√©m j√° vista retorna a posi√ß√£o atual do cursor</p>
<pre><code class="language-c">FILE *j = fopen(&quot;j.txt&quot;, &quot;r&quot;);

char c;
while ((c = fgetc(j)) != 'a')
  putchar(c);

printf(&quot;\n%li\n&quot;, ftell(j));
</code></pre>
<p>Mas caso voc√™ precise de mais controle nesse posicionamento √© s√≥ usar as fun√ß√µes <code>fgetpos</code> e <code>fsetpos</code></p>
<pre><code class="language-c">// j.txt -&gt; &quot;abcdefghijklmnop&quot;
FILE * arquivo = fopen(&quot;j.txt&quot;, &quot;r+&quot;);

fpos_t posicao; // tem que ser deste tipo para funcionar

fgetpos(arquivo, &amp;posicao); // pegando a posi√ß√£o
printf(&quot;posicao: %p\ncaractere: %c&quot;, &amp;posicao, fgetc(arquivo));
fseek( arquivo, 0, SEEK_SET );

fsetpos(arquivo, &amp;posicao + 4); // mudando posi√ß√£o para o 4 caractere
fgetpos(arquivo, &amp;posicao);     // pegando a posi√ß√£o de novo

getchar();

printf(&quot;posicao: %p\ncaractere: %c\n&quot;, &amp;posicao, fgetc(arquivo));
fclose ( arquivo );

getchar();
</code></pre>
<blockquote>
<p>Sa√≠da:</p>
</blockquote>
<pre><code>posicao: 0x7ffddf294270
caractere: a
posicao: 0x7ffddf294270
caractere: e
</code></pre>
<h3 id="opera√ß√µes-com-arquivos"><a class="header" href="#opera√ß√µes-com-arquivos">Opera√ß√µes com arquivos</a></h3>
<p>Para apagar o arquivo √© s√≥ usar a fun√ß√£o <code>remove</code></p>
<pre><code class="language-c">remove(&quot;j.txt&quot;);
</code></pre>
<p>E para renomear √© s√≥ usar <code>rename</code></p>
<pre><code class="language-c">rename(       &quot;j.txt&quot;,  &quot;joao.txt&quot;);
//    ( &lt;nome antigo&gt;, &lt;nome novo&gt;)
</code></pre>
<p>A fun√ß√£o <code>reopen</code> √© muito √∫til para mudar o destino de arquivos, exemplo:</p>
<pre><code class="language-c">freopen(&quot;j.txt&quot;, &quot;w&quot;, stdout);
fprintf(&quot;joao √© uma pessoa!!\n&quot;, stdout); // o resultado n√£o ser√° impresso na tela, mas no arquivo &quot;j.txt&quot;
</code></pre>
<p>Al√©m de todas essas, lembra de quando imprimimos mensagens na sa√≠da de erro (<code>stderr</code>) com <code>fprintf</code>? na <code>stdio.h</code> existe uma que faz isso automaticamente; √© o <code>perror</code></p>
<pre><code class="language-c">perror(&quot;ferrou!!&quot;);
</code></pre>
<p>Para outras informa√ß√µes sobre a biblioteca veja a <a href="https://pt.wikibooks.org/wiki/Programar_em_C/Entrada_e_sa%C3%ADda_simples">refer√™ncia</a> que est√° no <a href="https://pt.wikibooks.org">wikibooks</a> sobre ela.</p>
<h2 id="stdlibh"><a class="header" href="#stdlibh">stdlib.h</a></h2>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
</code></pre>
<p>A <code>stdlib.h</code> √© com certeza uma das bibliotecas mais importantes do C, portanto, merece ser dicecada aqui.</p>
<p>E as fun√ß√µes que j√° vimos dela foram as de gerenciamento de mem√≥ria (<code>malloc</code>, <code>free</code>, <code>realloc</code>), logo, n√£o iremos rev√™-las.</p>
<h3 id="convers√µes-entre-string-e-outros-tipos"><a class="header" href="#convers√µes-entre-string-e-outros-tipos">Convers√µes entre string e outros tipos</a></h3>
<pre><code class="language-c">double     d = atof (&quot;8.9&quot;); // atof(&lt;valor&gt;): de string para double
int        i = atoi (&quot;89&quot;);  // atoi(&lt;valor&gt;): de string para inteiro
long       l = atol (&quot;999&quot;); // atol(&lt;valor&gt;): de string para long
long long ll = atoll (&quot;99&quot;); // atoll(&lt;valor&gt;): de string para long long
</code></pre>
<h3 id="sistema"><a class="header" href="#sistema">Sistema</a></h3>
<p>Caso queira abortar o programa, voc√™ pode usar a fun√ß√£o <code>exit</code>, e assim como no <code>return</code> do main, voc√™ escolhe o valor que quer retornar para o SO</p>
<pre><code class="language-c">int i;

scanf(&quot;%i&quot;, &amp;i);
if (i%2)
  exit(0); // se for impar saia
else
  exit(1); // senao saia e retorne um erro
</code></pre>
<p>Outra fun√ß√£o relacionada ao fechamento do programa √© a fun√ß√£o <code>atexit</code>, que registra fun√ß√µes que ser√£o executadas quando o programa finalizar, sendo que estas fun√ß√µes n√£o podem retornar valores e nem receber parametros.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void tmp_file_remove (void){
  remove(&quot;/tmp/at_exit_lock&quot;);
}

int main(){
  FILE * tmp = fopen(&quot;/tmp/at_exit_lock&quot;, &quot;w&quot;);
  atexit(tmp_file_remove);

  // pausando a execu√ß√£o
  puts(&quot;n√£o click em enter ainda... olhe se h√° um arquivo \&quot;at_exit_lock\&quot; na pasta /tmp/&quot;);
  getchar();

  puts(&quot;agora veja se ainda est√° l√°&quot;);
  fclose (tmp);
  return 0;
}
</code></pre>
<p>Outra semelhante √† <code>atexit</code> √© a <code>at_quick_exit</code>, que vai ser executada quando o programa for interromido usando a fun√ß√£o <code>quick_exit</code></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void tmp_file_remove (void){
  remove(&quot;/tmp/at_exit_lock&quot;);
}

int main(){
  FILE * tmp = fopen(&quot;/tmp/at_exit_lock&quot;, &quot;w&quot;);
  atexit(tmp_file_remove);

  // pausando a execu√ß√£o
  puts(&quot;n√£o click em enter ainda... olhe se h√° um arquivo \&quot;at_exit_lock\&quot; na pasta /tmp/&quot;);
  getchar();

  fclose (tmp);
  quick_exit(0);

  // essa parte n√£o vai executar
  puts(&quot;agora veja se ainda est√° l√°&quot;);
  return 0;
}
</code></pre>
<p>Outra vari√°vel de sistema muito √∫til √© a <code>getenv</code>, que retorna o valor de uma vari√°vel de ambiente.</p>
<pre><code class="language-c">char path = getenv(&quot;PATH&quot;); // caminhos para execut√°veis no linux ($PATH)
</code></pre>
<p>E as mais √∫teis de todas, com essas voc√™ vai conseguir executar comandos do sistema operacional</p>
<pre><code class="language-c">system( &quot;echo hello mundo!&quot; ); // system( &lt;comando&gt; )
</code></pre>
<p>Mas a <code>system</code> executa e manda o resultado para a <code>stdout</code>, se voc√™ quiser acessar o valor de retorno, tem que usar a fun√ß√£o <code>popen</code> (que retorna um <code>stream</code>, logo, voc√™ vai ter que trat√°-la como um arquivo)</p>
<blockquote>
<p>A fun√ß√£o popen n√£o funciona no C99, se seu compilador usa C99, n√£o ir√° compilar.</p>
</blockquote>
<pre><code class="language-c">FILE *response = popen(&quot;echo hello mundo!&quot;, &quot;r&quot;); // popen( &lt;comando&gt; )

char comando [20];
fgets(comando, 20, response);
printf(&quot;o a resposta do comando usado foi:\n%s\n&quot;, comando);
</code></pre>
<p>Ainda faltam algumas fun√ß√µes mas essas s√£o as mais importantes (contando com as de alocamanto de mem√≥ria),  para outras informa√ß√µes sobre a biblioteca, consulte a <a href="https://pt.wikipedia.org/wiki/Stdlib.h">refer√™ncia</a> feita por algu√©m na <a href="http://wikipedia.org/wiki/Stdlib.h">wikipedia</a>.</p>
<h2 id="mathh"><a class="header" href="#mathh">math.h</a></h2>
<pre><code class="language-c">#include &lt;math.h&gt;
</code></pre>
<p>Com certeza toda linguagem que se presa tem uma biblioteca de matem√°tica, a <code>math.h</code> tem diversas fun√ß√µes para resolu√ß√£o de problemas matem√°ticos desde arredondamento at√© trigonom√©tricos.</p>
<h3 id="fun√ß√µes-de-arredondamento"><a class="header" href="#fun√ß√µes-de-arredondamento">Fun√ß√µes de arredondamento</a></h3>
<p>Digamos que o valor de uma opera√ß√£o d√™ <code>1.7</code>, se quisermos arredond√°-lo para cima usamos a fun√ß√£o <code>ceil</code>:</p>
<pre><code class="language-c">printf(&quot;%f\n&quot;, ceil(1.7));
</code></pre>
<p>Mas se quisermos arredond√°-lo para um n√∫mero menor usamos a fun√ß√£o <code>floor</code>:</p>
<pre><code class="language-c">printf(&quot;%f\n&quot;, floor(1.7));
</code></pre>
<p>E se quiser apenas cortar a parte decimal use o <code>trunc</code>:</p>
<pre><code class="language-c">printf(&quot;%f\n&quot;, trunk(1.7));
</code></pre>
<p>Outra op√ß√£o √© arredondar para o n√∫mero inteiro mais pr√≥ximo, seja ele acima ou abaixo:</p>
<pre><code class="language-c">printf(&quot;%f\n&quot;, round(1.7));
</code></pre>
<p>A fun√ß√£o <code>round</code> tem algumas varia√ß√µes como o <code>lround</code> que arredonda para um <code>long int</code> e o <code>llround</code> que arredonda para um <code>long long int</code>.</p>
<h3 id="potencia-e-radicia√ß√£o"><a class="header" href="#potencia-e-radicia√ß√£o">Potencia e radicia√ß√£o</a></h3>
<p>Para realizar uma potencia√ß√£o √© s√≥ usar a fun√ß√£o <code>pow</code></p>
<pre><code class="language-c">printf(&quot;40 ao quadrado √© %.0f&quot;, pow(40, 2));
</code></pre>
<p>E caso queira fazer uma raiz quadrada √© s√≥ usar a fun√ß√£o <code>sqrt</code></p>
<pre><code class="language-c">float n = pow(40, 2);
printf(&quot;a raiz quadrada de %.0f √© %.0f&quot;, n, sqrt(n) );
</code></pre>
<p>E raiz c√∫bica √© <code>cbrt</code></p>
<pre><code class="language-c">float n = pow(40, 3);
printf(&quot;a raiz quadrada de %.0f √© %.0f&quot;, n, cbrt(n) );
</code></pre>
<p>E caso voc√™ queira fazer uma raiz de √≠ndice <code>5</code>, <code>4</code> ou qualquer outro n√∫mero, lemre-se que uma radicia√ß√£o √© apenas uma potencia elevada √† um expoente ‚Äúao contr√°rio‚Äù:</p>
<blockquote>
<p>2 normal √© igual a 2/1, 2 ao contr√°rio √© igual a 1/2</p>
</blockquote>
<pre><code class="language-c">// vou usar o expoente 2 mas funciona com qualquer valor
int numero = pow(5, 2);                  // 25
int outro_numero = pow(numero, 1.0/2.0); // 5

printf(&quot;5¬≤  = %i\n‚àö25 = %i\n&quot;, numero, outro_numero);
</code></pre>
<blockquote>
<p>E n√£o esque√ßa dos <code>.0</code> ap√≥s o n√∫mero se voc√™ n√£o fizer isso o valor do expoente vai ser um inteiro e portanto, ser√° <code>0</code>, lunca se esque√ßa de checar os tipos primitivos...</p>
</blockquote>
<p>E existe uma rotina exclusiva para c√°lculo de hipotenusa:</p>
<pre><code class="language-c">int cateto_oposto = 8, cateto_adjacente = 6;
int hipotenusa = hypot( cateto_oposto, cateto_adjacente );
</code></pre>
<p>A biblioteca de matem√°tica tem diversas outras fun√ß√µes, logo, caso necessite fazer algoritmos matem√°ticos consulte a <a href="https://www.ufrgs.br/reamat/ComputacaoCientifica/livro/iapcel-a_biblioteca_mathh.html">refer√™ncia da math.h</a> feita pela <a href="https://www.ufrgs.br">UFRGS</a></p>
<h2 id="stdargh"><a class="header" href="#stdargh">stdarg.h</a></h2>
<pre><code class="language-c">#include &lt;stdarg.h&gt;
</code></pre>
<p>A <code>stdarg.h</code> √© uma biblioteca para tratamento de argumentos (ou parametros) de fun√ß√µes.</p>
<p>At√© aqui voc√™ deve est√° se perguntando, <em>‚Äúcomo fazer fun√ß√µes como o <code>printf</code> ou o <code>scanf</code> que recebem um n√∫mero indeterminado de argumentos?‚Äù</em>, exatamente usando esta biblioteca, mas preste aten√ß√£o para entender como voc√™ pode us√°-la em seus algor√≠tmos.</p>
<p>Para essa biblioteca, vou explicar de uma maneira diferente, aqui n√≥s vamos criar o <code>print</code>, que assim como o <code>printf</code>, ir√° esquever coisas na tela.</p>
<blockquote>
<p>Como vai ser a chamada do <code>print</code></p>
</blockquote>
<pre><code class="language-c">// print ( &lt;formato&gt;, &lt;dados&gt; );

print( &quot;isfsf&quot;, 90, &quot; + &quot;, 8.3, &quot; = &quot;, 90.0 + 8.3 );

// i -&gt; %i/%d/%li
// s -&gt; %s
// f -&gt; %f/%lf
</code></pre>
<p>Na declara√ß√£o da fun√ß√£o tem que ter pelo menos 1 argumento fixo, e no nosso caso √© o <code>formato</code>, todos os outros argumentos ser√£o substitu√≠dos por um <code>...</code></p>
<pre><code class="language-c">void print( char * formato, ... );
</code></pre>
<p>Para acessar os dados no <code>...</code> n√≥s primeiro temos que guardar eles em uma vari√°vel do tipo <code>va_list</code></p>
<pre><code class="language-c">void print( char * formato, ... ){
  va_list argumentos;
}
</code></pre>
<p>Esse va_list √© um ponteiro com todos os argumentos, mas para pegarmos os certos temos que dizer para ele de onde come√ßar a pesquisar usando o <code>va_start</code></p>
<pre><code class="language-c">void print( char * formato, ... ){
  va_list argumentos;
  va_start( argumentos, formato );
}
</code></pre>
<p>Agora iremos checar quantos dados estamos esperando, e depois pegar-los com a fun√ß√£o <code>va_arg</code></p>
<blockquote>
<p>Caso for usar valores em <code>char</code>, na hora de usar o <code>va_arg</code>, usem com <code>int</code>, ele n√£o aceita <code>char</code> porque √© muito pequeno.</p>
</blockquote>
<pre><code class="language-c">#include &lt;string.h&gt; // -&gt; strlen
void print( char * formato, ... ){
  va_list argumentos;
  va_start( argumentos, formato );

  int argc = strlen(formato); // pegando a qntd de caracteres da string

  for (int i = 0; i&lt;argc; i ++){
    if (formato[ i ] == 'i') // caso o dado esperado for um int
      printf( &quot;%li&quot;, va_arg( argumentos,      long int ) );
      //             va_arg( &lt;lista de args&gt;,   &lt;tipo&gt; ) );

    if (formato[ i ] == 'f') // float
      printf( &quot;%lf&quot;, va_arg( argumentos, double ) );

    if (formato[ i ] == 's') // string
      printf(va_arg( argumentos, char *));
  }
  putchar('\n');
  va_end( argumentos ); // fechando os argumentos
}
</code></pre>
<blockquote>
<p>O <code>va_arg</code>, assim como o <code>fgetf</code>, retorna o dado e passa para o pr√≥ximo automaticamente.</p>
</blockquote>
<p>E fim, essas s√£o as √∫nicas fun√ß√µes que existem nessa biblioteca. Mas como eu prometi no cap√≠tulo sobre <code>stdio.h</code> agora eu irei explicar sobre as fun√ß√µes que usam o <code>va_list</code> da <code>stdarg.h</code></p>
<p>As fun√ß√µes do <code>stdio.h</code> que usam <code>va_list</code> fazem o mesmo que as outras, s√≥ que aceitam esse tipo de argumento, como o <code>vprintf</code></p>
<pre><code class="language-c">void escreva_numeros ( int qntd, ... ){
  va_list args;
  va_start( args, qntd );

  char * formato = malloc( qnt*3+1 );
  for (int i=0; i&lt;qntd; i+=2){
    formato[i] = '%';
    formato[i+1] = 'i';
    formato[i+2] = 'i';
  }
  formato[ qnt*3 ] = '\n';

  vprintf(formato, args);

  va_end( args );
  free(formato);
}
</code></pre>
<p>E funciona da mesma maneira com as fun√ß√µes <code>vscanf</code> (<code>scanf</code>), <code>vsscanf</code> (<code>sscanf</code>), <code>vfscanf</code> (<code>fscanf</code>) ...</p>
<h2 id="stringh"><a class="header" href="#stringh">string.h</a></h2>
<pre><code class="language-c">#include &lt;string.h&gt;
</code></pre>
<p>Esta √© mais uma das bibliotecas que eu j√° falei, mas n√£o me aprofundei, portanto irei ignorar as fun√ß√µes j√° mencionadas (<code>strlen</code>, <code>strcpy</code>).</p>
<p>A primeira fun√ß√£o interessante √© a <code>strncpy</code>, que ao inv√©s de copiar a string inteira, copia apenas um n√∫mero de caracteres</p>
<pre><code class="language-c">char str[10];
strncpy(str, &quot;joao e maria&quot;, 4); // copia at√© o 4 caractere
str[4] = '\0';                   // setando o fim da string

puts(str);
</code></pre>
<blockquote>
<p>Sa√≠da:</p>
</blockquote>
<pre><code>joao
</code></pre>
<p>Outra que tamb√©m √© bacana √© a <code>strcat</code>, que serve para concatenar strings</p>
<pre><code class="language-c">char str[] = &quot;joao&quot;;
strcat(str, &quot; e maria&quot;); // strcat( &lt;destino&gt;, &lt;destinatario&gt; );
</code></pre>
<p>E existe a varia√ß√£o <code>strncat</code>, que concatena at√© um certo n√∫mero de caracteres</p>
<pre><code class="language-c">char str[] = &quot;joao&quot;;
strncat(str, &quot; e maria rosa&quot;, 8);
</code></pre>
<p>Uma fun√ß√£o muito √∫til dessa biblioteca √© a <code>strcmp</code> que compara duas strings</p>
<pre><code class="language-c">char str [] = &quot;joao&quot;, str2 [] = &quot;maria&quot;;
int res = strcmp( str, str2 ); // strcmp( &lt;str&gt;, &lt;str2&gt; )

if ( res == 0 )
  puts(&quot;as strings s√£o iguais&quot;);
else if ( res &lt; 0 )
  puts(&quot;\&quot;%s\&quot; √© menor que \&quot;%s\&quot;&quot;, str, str2);
else if ( res &gt; 0 )
  puts(&quot;\&quot;%s\&quot; √© maior que \&quot;%s\&quot;&quot;, str, str2);
</code></pre>
<p>E tamb√©m existe a <code>strncmp</code> que funciona da mesma forma que a anterior, mas compara s√≥ at√© um certo caractere.</p>
<pre><code class="language-c">char str [] = &quot;joao&quot;, str2 [] = &quot;joao e maria&quot;;
int res = strncmp( str, str2, 4 ); // strncmp( &lt;str&gt;, &lt;str2&gt;, &lt;numero&gt; )

if (res == 0)
  puts(&quot;os primeiros 4 caracteres da string 2 s√£o iguais aos da string 1&quot;);
</code></pre>
<p>Outras op√ß√µes s√£o usar fun√ß√µes de pesquisa em strings, como o <code>strchr</code> que ir√° retornar um ponteiro para a primeira ocorrencia de um caractere</p>
<pre><code class="language-c">char j[] = &quot;abcdefghijklmnop;joao\0&quot;;
puts(strchr(j, 'g'));
puts(strchr(j, ';')+1);

char * f = strchr(j, ';');
* f = '\0'; /* finalizando a string
               na primeira ocorrencia
               de &quot;;&quot; */

puts(j);
</code></pre>
<blockquote>
<p>Sa√≠da:</p>
</blockquote>
<pre><code>ghijklmnop;joao
joao
abcdefghijklmnop
</code></pre>
<p>Outra bem bacana √© a <code>strcspn</code> onde voc√™ passa uma certa lista de caracteres e ela ir√° retornar a primeira ocorrencia de qualquer caractere da lista</p>
<pre><code class="language-c">char str[] = &quot;bcdefgh&quot;;
printf(&quot;A vogal \&quot;%c\&quot; est√° na %i¬™ posi√ß√£o de \&quot;%s\&quot;\n&quot;,
    str[ strcspn(str, &quot;aeiou&quot;) ], strcspn(str, &quot;aeiou&quot;)+1, str);
</code></pre>
<blockquote>
<p>Sa√≠da:</p>
</blockquote>
<pre><code>A vogal &quot;e&quot; est√° na 4¬™ posi√ß√£o de &quot;bcdefgh&quot;
</code></pre>
<p>Uma semelhante a <code>strchr</code> √© a <code>strstr</code>, que retorna a string da primeira ocorrencia de um caractere at√© o seu fim</p>
<pre><code class="language-c">char str[] = &quot;joao maria ronaldo&quot;;
puts(strstr(str, &quot;maria&quot;));
</code></pre>
<h2 id="ctypeh"><a class="header" href="#ctypeh">ctype.h</a></h2>
<pre><code class="language-c">#include &lt;ctype.h&gt;
</code></pre>
<p>Esta biblioteca possui fun√ß√µes para reconhecimento de tipos de caractere (<code>char</code>), e carrega diversas fun√ß√µes para esse reconhecimento.</p>
<pre><code class="language-c">isnum    ('2'); // se √© numerico
isalpha  ('s'); // se √© alfab√©tico
isblank ('\t'); // se √© vazio
iscntrl ('\n'); // se √© caractere especial
isdigit  ('4'); // se √© numero decimal
isgraph  ('!'); // se tem representa√ß√£o gr√°fica
isprint  ('2'); // se d√° para escrever na tela
ispunct  ('.'); // se √© pontua√ß√£o
isspace ('\v'); // se √© um espa√ßo branco
isxdigit ('0'); // se √© hexadecimal
islower  ('a'); // se √© letra min√∫scula
isupper  ('A'); // se √© letra mai√∫scula

tolower  ('A'); // transforma em letra min√∫scula
toupper  ('a'); // transforma em letra mai√∫scula
</code></pre>
<p>√â necess√°rio que eu esclare√ßa alguns pontos, caracteres como <code>Ôû∂</code> ou <code>√ß</code> s√£o grandes demais para caber em um <code>char</code>, caso precise desses caracteres unicode, use strings para represent√°-los.</p>
<h2 id="conioh"><a class="header" href="#conioh">conio.h</a></h2>
<pre><code class="language-c">#include &lt;conio.h&gt;
</code></pre>
<p>Esta √© uma biblioteca exclusiva para sistemas baseados em <a href="https://pt.wikipedia.org/wiki/MS-DOS">MS-DOS</a>, como o windows, ou o <a href="https://pt.wikipedia.org/wiki/ReactOS">reactOS</a>, e serve para a entrada e sa√≠da de dados com o console.</p>
<p>A fun√ß√£o mais interessante √© sem d√∫vidas a <code>getch</code>, que basicamente espera um caractere.</p>
<pre><code class="language-c">char c;

printf(&quot;digite um caractere&quot;);
c = getch();
</code></pre>
<blockquote>
<p>Ele n√£o espera um ‚Äúenter‚Äù, ele apenas recebe o caractere e pronto.</p>
</blockquote>
<p>Outra forma legal de usar esta fun√ß√£o √© pra controlar a entrada do usu√°rio, por exemplo, quero ler um texto eternamente e parar quando a pessoa clicar na tecla <kbd>esc</kbd>.</p>
<pre><code class="language-c">#include &lt;conio.h&gt;
#include &lt;stdio.h&gt;

int main(){
    puts(&quot;digite coisas aqui:&quot;);

    char c, *str = malloc(1);
    int i = 0;
    while ((c = getch()) != 27){ /* enquanto o caractere lido
                                    for diferente da
                                    tecla &lt;ESC&gt;
                                 */
        putchar(c);
        str = realloc(str, sizeof str + sizeof c);
        str[i++] = c;
    }

    printf(&quot;\n%s\n&quot;, str);
    free(str);
    return 0;
}
</code></pre>
<p>Bom, basicamente √© isso, todas as outras fun√ß√µes s√£o apenas alternativas a j√° existentes como o <code>cgets</code> que funciona igual a <code>gets</code> do <code>stdio.h</code>, ou a <code>cprintf</code>... enfim.</p>
<h1 id="considera√ß√µes-finais"><a class="header" href="#considera√ß√µes-finais">Considera√ß√µes finais</a></h1>
<p>Espero que este livro tenha ajudado voc√™, este n√£o √© o fim definitivo, os seus estudos n√£o devem acabar aqui, ent√£o tenha paci√™ncia e antes de ir embora vou da um b√¥nus para voc√™ se animar e come√ßar seus projetos em C.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
